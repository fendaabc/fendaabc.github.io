<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/03/05/Terminator%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"/>
      <url>2021/03/05/Terminator%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>打开命令窗口 ctrl+alt+t</li><li>水平新建一个窗口 ctrl+shift+o</li><li>垂直新建一个窗口 </li><li>在不同窗口之间切换 alt+方向键</li><li>当前窗口最大化或恢复正常 ctrl+shift+x</li><li>粘贴  鼠标右键或者Ctrl+shift+v</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JucNote</title>
      <link href="2021/03/05/JucNote/"/>
      <url>2021/03/05/JucNote/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="几种状态"><a href="#几种状态" class="headerlink" title="几种状态"></a>几种状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span></span>&#123;</span><br><span class="line"><span class="comment">//新生</span></span><br><span class="line">NEW,</span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line">RUNNABLE,</span><br><span class="line"><span class="comment">//阻塞</span></span><br><span class="line">BLOCKED,</span><br><span class="line"><span class="comment">//等待</span></span><br><span class="line">WAITTING,</span><br><span class="line"><span class="comment">//延时等待</span></span><br><span class="line">TIMED_WAITTING,</span><br><span class="line"><span class="comment">//终止</span></span><br><span class="line">TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait-VS-sleep"><a href="#wait-VS-sleep" class="headerlink" title="wait VS sleep"></a>wait VS sleep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.来自不同的类</span></span><br><span class="line"><span class="built_in">wait</span> =&gt; Object    sleep =&gt; Thread</span><br><span class="line"><span class="comment"># 2.关于锁的释放</span></span><br><span class="line"><span class="built_in">wait</span> 会释放锁， sleep 抱着锁睡着了，不释放锁。</span><br><span class="line"><span class="comment"># 3.使用范围不同</span></span><br><span class="line"><span class="built_in">wait</span>  必须在同步代码块中（有另一个线程在等待）    </span><br><span class="line">sleep  任何地方都可以sleep</span><br><span class="line"><span class="comment"># 4.捕获异常？？</span></span><br><span class="line"><span class="built_in">wait</span>  不需要    sleep 需要</span><br></pre></td></tr></table></figure><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock </span><br><span class="line">ReentrantReadWriteLock.ReadLock </span><br><span class="line">ReentrantReadWriteLock.WriteLock</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/05/XjJAtCIm8skf7Uo.png" alt="image-20210305141956173"></p><p>公平锁：十分公平，可以先来后到</p><p><strong>非公平锁：可以插队（默认使用）</strong></p><h2 id="Synchronized-VS-Lock"><a href="#Synchronized-VS-Lock" class="headerlink" title="Synchronized VS Lock"></a>Synchronized VS Lock</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. Synchronized 内置的java关键字，lock是一个java类</span></span><br><span class="line"><span class="comment">#2. 。。。。。。。。无法判断锁的状态，。。。可以判断是否得到了锁</span></span><br><span class="line"><span class="comment">#3.  。。。。。。。会自动释放锁，。。。。。必须手动释放，否则死锁</span></span><br><span class="line"><span class="comment">#4. 。。。。。。。。线程1（获得锁，阻塞）线程2（等待）。。。Lock锁不一定会继续等待（）</span></span><br><span class="line"><span class="comment">#5. 。。。。。。。。可重入锁，不可中断，非公平；。。。。。。</span></span><br><span class="line"><span class="comment">#6. 。。。。。。。。适合锁少量的代码同步问题，。。。。。。。适合锁大量的同步代码</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/05/QdEPmrUpf89IBYs.png" alt="虚假唤醒"></p><h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a><strong>虚假唤醒</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api中建议我们在锁里面使用<span class="keyword">while</span>语句而非<span class="keyword">if</span>语句，避免出现虚假唤醒的情况。</span><br></pre></td></tr></table></figure><h2 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h2><ol><li>两个方法加synchronized关键字，调用方A执行完休息4s，然后调用方B执行，执行顺序永远</li></ol><p>先前一个方法然后后面这个，</p><ol start="2"><li>两个方法加synchronized关键字，第一个方法中先sleep 4s然后执行命令，调用方A B执行，执行顺序永远先前一个方法然后后面这个，因为synchronized关键字不会丢失锁，拿到了除非释放否则一直在。</li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RedisNote</title>
      <link href="2021/03/03/RedisNote/"/>
      <url>2021/03/03/RedisNote/</url>
      
        <content type="html"><![CDATA[<h1 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE（异地多活）</span><br><span class="line">- 高性能，高可用，高可扩</span><br></pre></td></tr></table></figure><h2 id="Nosql的四大分类："><a href="#Nosql的四大分类：" class="headerlink" title="Nosql的四大分类："></a>Nosql的四大分类：</h2><h3 id="KV键值对："><a href="#KV键值对：" class="headerlink" title="KV键值对："></a>KV键值对：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis    或    redis+tair   或     redis+memecache</span><br></pre></td></tr></table></figure><h3 id="文档性数据库（bson格式和json格式一样）："><a href="#文档性数据库（bson格式和json格式一样）：" class="headerlink" title="文档性数据库（bson格式和json格式一样）："></a><strong>文档性数据库</strong>（bson格式和json格式一样）：</h3><ul><li>MongoDB（需掌握）<ul><li>是基于分布式文件存储的数据库，c++编写，主要处理大量的文档</li><li>mongdb是介于关系型数据库和菲关系型数据库中间的产品（是菲关系型数据库中最像关系型数据库的）</li></ul></li></ul><h3 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a><strong>列存储数据库</strong></h3><ul><li>HBase</li><li>分布式文件系统</li></ul><h3 id="图关系数据库"><a href="#图关系数据库" class="headerlink" title="图关系数据库"></a><strong>图关系数据库</strong></h3><ul><li>拓扑图</li><li>Neo4j，infogrid</li></ul><h3 id="四大分类的对比"><a href="#四大分类的对比" class="headerlink" title="四大分类的对比"></a>四大分类的对比</h3><p><img src="https://i.loli.net/2021/03/03/wgaLzPVfcuKIieq.png" alt="image-20210303102453806">    </p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote><p>Redis（remote dictionary server） 远程字典服务</p></blockquote><h2 id="能干吗"><a href="#能干吗" class="headerlink" title="能干吗"></a><strong>能干吗</strong></h2><ol><li>内存存储、持久化（RDB AOF）</li><li>效率高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（浏览量 ）</li><li>。。。</li></ol><h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a><strong>特性</strong>：</h2><ol><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li><li>。。。</li></ol><h2 id="配置："><a href="#配置：" class="headerlink" title="配置："></a><strong>配置</strong>：</h2><p>下载安装redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 先安装gcc-c++，视频教程使用yum安装的，但ubuntu20.04我无法安装，输入gcc -v发现不知道什么时候我已经安装了gcc了，所以就直接使用了</span><br><span class="line">2. make</span><br><span class="line">3. make install</span><br><span class="line">4. redis的默认安装路径“/usr/<span class="built_in">local</span>/bin”</span><br><span class="line">5. 将redis压缩包下的配置文件拷贝到<span class="built_in">local</span>下的bin目录下的自定义目录</span><br><span class="line">6. 启动redis，修改配置文件中的daemonize no为yes (用后台的方式启动)</span><br><span class="line">7. 回到bin目录，运行启动命令 redis-server redisconfig/redis.conf (上面刚配置的)</span><br><span class="line">8. 启动以后进行连接，redis-cli -p 6379  ,用ping测试一下看能否返回pong</span><br><span class="line">(我的启动的时候redis-cli -p 6379输入完光标闪烁没反应，然后我将conf和这块的端口都改成了6279进行启动)</span><br></pre></td></tr></table></figure><h2 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h2><p><strong>redis-benchmark 压力测试工具</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试：100个并发 每个10w个请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6279 -c 100 -n 100000</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/03/C3XnDqleLPhFQ4y.png" alt="image-20210303122401611"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="https://i.loli.net/2021/03/03/Iv7w9lxkuaZdJ5f.png" alt="image-20210303123007123"></p><p>总共16个数据库，通过select可以选择需要使用的库，然后用set name value存储，用get name进行取出，flushdb刷库将当前库清空，flushall清楚全部库。</p><p>keys * 查看所有的key，</p><h2 id="RedisKey"><a href="#RedisKey" class="headerlink" title="RedisKey"></a>RedisKey</h2><blockquote><p>set、get、move、keys *、expire key 时间（设置过期时间秒数）、ttl key（查看还有多久过期）、type key（查看key的类型）</p></blockquote><p><img src="https://i.loli.net/2021/03/03/LSRpqixcZoDh5zH.png" alt="image-20210303145750335"></p><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p><img src="https://i.loli.net/2021/03/03/FTZNi3vpqOdhgs2.png" alt="image-20210303151217153"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########################指定步长进行加减操作#############################</span></span><br><span class="line">127.0.0.1:6279[1]&gt; <span class="built_in">set</span> num 0                           <span class="comment">#设置</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6279[1]&gt; get num       <span class="comment">#获取</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6279[1]&gt; incrby 2 num   <span class="comment">#步长2，指定增量</span></span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">127.0.0.1:6279[1]&gt; incrby  num 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6279[1]&gt; incrby  num 2</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6279[1]&gt; decrby num 1<span class="comment">#步长1，指定递减量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6279[1]&gt; decrby num 1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">#################################截取######################</span></span><br><span class="line">127.0.0.1:6279[1]&gt; <span class="built_in">set</span> key1 <span class="string">&quot;hello,xiaoming&quot;</span><span class="comment">#</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6279[1]&gt; get key1</span><br><span class="line"><span class="string">&quot;hello,xiaoming&quot;</span></span><br><span class="line">127.0.0.1:6279[1]&gt; getrange key1 0 3<span class="comment">#截取字符串[0,3]</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6279[1]&gt; getrange key1 0 -1<span class="comment">#截取全部字符串</span></span><br><span class="line"><span class="string">&quot;hello,xiaoming&quot;</span></span><br><span class="line">127.0.0.1:6279[1]&gt; </span><br><span class="line"><span class="comment">##############################指定位置替换###############################</span></span><br><span class="line">127.0.0.1:6279[1]&gt; <span class="built_in">set</span> key2 abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6279[1]&gt; get key2</span><br><span class="line"><span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">127.0.0.1:6279[1]&gt; setrange key2 1 xx                 <span class="comment">#替换指定位置开始的字符串</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6279[1]&gt; get key2</span><br><span class="line"><span class="string">&quot;axxdefg&quot;</span></span><br><span class="line"><span class="comment">#############################判断是否存在###############################</span></span><br><span class="line"><span class="comment">#setex （set with expire）   设置过期时间</span></span><br><span class="line"><span class="comment">#setnx  （set if not exist） 不存在就设置，返回1设置成功，否则返回0设置失败（分布式锁）</span></span><br><span class="line">127.0.0.1:6279[1]&gt; setex key3 30 <span class="string">&quot;hello&quot;</span>   <span class="comment">#设置key3为hello 30秒过期</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6279[1]&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) 26</span><br><span class="line">127.0.0.1:6279[1]&gt; get key3</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6279[1]&gt; setnx mykey <span class="string">&quot;redis&quot;</span><span class="comment">#mykey不存在 设置为redis</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6279[1]&gt; setnx mykey <span class="string">&quot;666&quot;</span><span class="comment">#如果mykey存在，则无法设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">##########################同时set get多个值###########################</span></span><br><span class="line">127.0.0.1:6279[1]&gt; mset k1 v1 k2 v2 k3 v3     <span class="comment">#同时设置k1 k2 k3</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6279[1]&gt; mget k1 k2 k3              <span class="comment">#同时获取</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6279[1]&gt; msetnx k1 6 k2 7 k3 8      <span class="comment">#如果不存在则同时设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 0                                   <span class="comment">#返回0表示设置失败</span></span><br><span class="line">127.0.0.1:6279[1]&gt; mget k1 k2 k3              </span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6279[1]&gt; msetnx k4 7 k5 8 k6 9       </span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment">#返回1 表示设置成功</span></span><br><span class="line">127.0.0.1:6279[1]&gt; mget k4 k5 k6</span><br><span class="line">1) <span class="string">&quot;7&quot;</span></span><br><span class="line">2) <span class="string">&quot;8&quot;</span></span><br><span class="line">3) <span class="string">&quot;9&quot;</span></span><br><span class="line">127.0.0.1:6279&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6279&gt; msetnx k1 v2 k2 v3<span class="comment">#事务特性，k1失败全部失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>在redis中，可以将list当做堆、栈或者队列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########################放入元素#########################</span></span><br><span class="line">127.0.0.1:6279&gt; lpush list one    <span class="comment">#将一个或多个值插入队列头部（左）</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6279&gt; lpush list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6279&gt; lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6279&gt; lrange list 0 -1   <span class="comment">#查询队列的中的全部值（从左到右）</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6279&gt; rpush list righr   <span class="comment">#将一个或多个值插入队列尾部（右）</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6279&gt; lrange list 0 -1   <span class="comment">#查询队列的中的全部值（从左到右）</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;righr&quot;</span></span><br><span class="line"><span class="comment">#########################移除元素#########################</span></span><br><span class="line">127.0.0.1:6279&gt; lpop list          <span class="comment">#移除第一个元素（从左边）</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6279&gt; rpop list          <span class="comment">#移除第一个元素（从右边）</span></span><br><span class="line"><span class="string">&quot;righr&quot;</span></span><br><span class="line">127.0.0.1:6279&gt; lrange list 0 -1   <span class="comment">#查询所有元素</span></span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment">#########################获取元素#########################</span></span><br><span class="line">lindex list 数字                        <span class="comment">#获取第n个元素（从左边）</span></span><br><span class="line">rlindex list 数字      <span class="comment">#获取第n个元素（从右边）</span></span><br><span class="line"><span class="comment">#########################获取长度#########################</span></span><br><span class="line">llen list                              <span class="comment">#获取list长度</span></span><br><span class="line"><span class="comment">#########################移除指定元素#########################</span></span><br><span class="line">ltrim list 1  2</span><br><span class="line"><span class="comment">#########################插入元素##########################从左边截取</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>实际是一个链表，before Node after ，left，right 都可以插入值</li><li>如果key不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高，中间元素，相对来说效率低</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##########################新增元素###################################</span></span><br><span class="line">127.0.0.1:6279&gt; sadd myset <span class="string">&quot;hello&quot;</span>             <span class="comment">#新增元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6279&gt; sadd myset <span class="string">&quot;xiaoming:</span></span><br><span class="line"><span class="string">Invalid argument(s)</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; sadd myset &quot;</span>xiaoming<span class="string">&quot;</span></span><br><span class="line"><span class="string">(integer) 1</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; sadd myset &quot;</span>chuiniubi<span class="string">&quot; </span></span><br><span class="line"><span class="string">(integer) 1</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; smembers mysest                 </span></span><br><span class="line"><span class="string">(empty array)</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; smembers myset                #展示set中所有的元素</span></span><br><span class="line"><span class="string">1) &quot;</span>xiaoming<span class="string">&quot;</span></span><br><span class="line"><span class="string">2) &quot;</span>chuiniubi<span class="string">&quot;</span></span><br><span class="line"><span class="string">3) &quot;</span>hello<span class="string">&quot;</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; sismember myset ho            #判断一个元素是否在set中</span></span><br><span class="line"><span class="string">(integer) 0</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; sismember myset hello</span></span><br><span class="line"><span class="string">(integer) 1</span></span><br><span class="line"><span class="string">##########################移除元素###################################</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; smembers myset</span></span><br><span class="line"><span class="string">1) &quot;</span>xiaoming<span class="string">&quot;</span></span><br><span class="line"><span class="string">2) &quot;</span>chuiniubi<span class="string">&quot;</span></span><br><span class="line"><span class="string">3) &quot;</span>hello<span class="string">&quot;</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; spop myset #随机移除元素</span></span><br><span class="line"><span class="string">&quot;</span>hello<span class="string">&quot;</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; spop myset</span></span><br><span class="line"><span class="string">&quot;</span>xiaoming<span class="string">&quot;</span></span><br><span class="line"><span class="string">##########################并集 交集 差集################################</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; sdiff myset myset2            #差集</span></span><br><span class="line"><span class="string">1) &quot;</span>hell<span class="string">&quot;</span></span><br><span class="line"><span class="string">2) &quot;</span>world<span class="string">&quot;</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; sinter myset myset2  #交集</span></span><br><span class="line"><span class="string">(empty array)</span></span><br><span class="line"><span class="string">127.0.0.1:6279&gt; sunion myset myset2  #并集</span></span><br><span class="line"><span class="string">1) &quot;</span>niubi<span class="string">&quot;</span></span><br><span class="line"><span class="string">2) &quot;</span>hell<span class="string">&quot;</span></span><br><span class="line"><span class="string">3) &quot;</span>world<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Map集合，key-map</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##########################存取#################################</span></span><br><span class="line">127.0.0.1:6279&gt; hset myhash name1  xiaoming       <span class="comment">#存一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6279&gt; hget myhash name1<span class="comment">#取一个值</span></span><br><span class="line"><span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">127.0.0.1:6279&gt; hmset myhash name1 xiaoming name2 xiaohong     <span class="comment">#存多个值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6279&gt; hmget myhash name1 name2<span class="comment">#获取多个值</span></span><br><span class="line">1) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">127.0.0.1:6279&gt; hgetall myhash<span class="comment">#获取全部值</span></span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">3) <span class="string">&quot;name2&quot;</span></span><br><span class="line">4) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">127.0.0.1:6279&gt; hlen myhash<span class="comment">#获取hash表的字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">带score值，可以排序</span><br></pre></td></tr></table></figure><h4 id="……"><a href="#……" class="headerlink" title="……"></a>……</h4><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>本质：一组命令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行。</p><p>redis单条命令保存原子性，但==事务不保证原子性。==</p><p>==事务没有隔离级别的概念。==</p></blockquote><p>redis的事务：</p><ul><li>开启事务(multi)</li><li>命令入队(…..)</li><li>执行事务(exec)/取消事务（discard）</li></ul><blockquote><p>正常执行事务：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6279&gt; multi <span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6279(TX)&gt; <span class="built_in">set</span> k1 v1<span class="comment">#命令入队 1</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6279(TX)&gt; <span class="built_in">set</span> k2 v2<span class="comment">#命令入队 2</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6279(TX)&gt; <span class="built_in">set</span> k3 v3<span class="comment">#命令入队 3</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6279(TX)&gt; get k2<span class="comment">#命令入队 4</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6279(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6279(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行事务</span></span><br><span class="line">1) OK<span class="comment">#执行结果</span></span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">5) OK</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>==编译型异常==（代码问题！命令有错） 事务中的所有命令==都不==执行</p></blockquote><blockquote><p>==运行时异常==（1/0）,如果事务队列中存在语法性，那么执行的时候其他命令可以==正常执行==，错误命令抛出异常</p></blockquote><p><strong>悲观锁</strong>：总是加锁</p><p><strong>乐观锁</strong>：总是不加锁（使用场景秒杀）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用watch进行监控，如果值被其他线程修改，<span class="built_in">exec</span>执行失败的话，需要unwatch取消监控，然后重新监控重新进行执行</span><br></pre></td></tr></table></figure><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><blockquote><p>使用java来操作redis，是官方推荐的java连接开发工具，使用java操作redis中间件</p></blockquote><h2 id="Springboot整合"><a href="#Springboot整合" class="headerlink" title="Springboot整合"></a>Springboot整合</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Springboot2.x之后的jedis被替换为<strong>lettuce</strong>：</p><p>jedis：采用的直连，多线程操作不安全，如果想避免不安全，使用jedis pool连接池</p><p>lettuce:采用netty，实例在多线程中共享，不存在线程不安全的清空，可以减少线程数据，更像NIO模式</p></blockquote><h3 id="看源码："><a href="#看源码：" class="headerlink" title="看源码："></a><strong>看源码：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 从自动配置入手，搜索autoconfiguration</span><br><span class="line">2. 找到以后进入spring.factories中，然后搜索redis，找到后跟踪源码，</span><br><span class="line">3. 从注解上的Redisproperties跟踪进入可以看到我们在yaml文件中能对redis进行哪些配置操作</span><br><span class="line">4. 不进入注解的话下面能看到springdata已经默认为我们生成的两个类，一个是redisTemplate，另一个stringRedisTemplate，在项目中自动注入以后可以直接使用，也可以重新进行修改</span><br></pre></td></tr></table></figure><h2 id="Redis-conf"><a href="#Redis-conf" class="headerlink" title="Redis.conf"></a>Redis.conf</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###################网络配置##########################</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1 -::1 <span class="comment">#绑定的ip</span></span><br><span class="line">protected-mode yes      <span class="comment">#保护模式</span></span><br><span class="line">port 6279 <span class="comment">#端口</span></span><br><span class="line"><span class="comment">###################通用配置##########################</span></span><br><span class="line">daemonize yes<span class="comment">#以守护进程方式运行（默认No）</span></span><br><span class="line">pidfile /var/run/redis_6379.pid   <span class="comment">#如果上面是yes，就需要指定一个pid文件</span></span><br><span class="line">logfile                 <span class="comment">#日志的文件位置名</span></span><br><span class="line">database 16             <span class="comment">#数据库的数量 默认16个</span></span><br><span class="line"><span class="comment">###################快照配置##########################</span></span><br><span class="line"><span class="comment">#可以根据需要进行自己的持久化修改</span></span><br><span class="line">在规定时间内，执行了多少次操作，则会持久化到文件 .rdb  .aof</span><br><span class="line">save 3600 1    <span class="comment">#若3600s内至少有一个key进行了修改，则进行持久化</span></span><br><span class="line">save 300 100<span class="comment">#..300s........100.........................</span></span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error no       <span class="comment">#如果持久化出错是否继续工作</span></span><br><span class="line">rdbcompression yes<span class="comment">#是否压缩rdb文件</span></span><br><span class="line">dir ./<span class="comment">#rdb文件保存的位置</span></span><br><span class="line"><span class="comment">###################安全配置##########################</span></span><br><span class="line">requirepass             <span class="comment">#是否需要密码，默认没有，一般需要设置在后面直接写就好</span></span><br><span class="line"><span class="comment">###################客户端配置##########################</span></span><br><span class="line">maxclients 10000        <span class="comment">#最大的客户端的数量</span></span><br><span class="line">maxmemory &lt;bytes&gt;       <span class="comment">#redis设置的最大内存容量</span></span><br><span class="line">maxmemory-policy noeviction <span class="comment">#内存到达上线后的处理策略</span></span><br><span class="line">------&gt; 六大过期策略：</span><br><span class="line"> 1.volatile-lru：只对设置了过期时间的key进行LRU（默认值） </span><br><span class="line">2.allkeys-lru ： 删除lru算法的key   </span><br><span class="line">3.volatile-random：随机删除即将过期key   </span><br><span class="line">4.allkeys-random：随机删除   </span><br><span class="line">5.volatile-ttl ： 删除即将过期的   </span><br><span class="line">6.noeviction ： 永不过期，返回错误  </span><br><span class="line"><span class="comment">###################AOF配置##########################</span></span><br><span class="line">appendonly no   <span class="comment">#默认aof不开启，使用rdb</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>   <span class="comment">#aof文件名</span></span><br><span class="line">appendfsync everysec   <span class="comment">#每秒同步一次（可能丢失这一秒的数据）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB（Redis-Data-Base）"><a href="#RDB（Redis-Data-Base）" class="headerlink" title="RDB（Redis Data Base）"></a>RDB（Redis Data Base）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> save的规则满足的情况下，会自动触发rdb规则</span><br><span class="line"><span class="bullet">2.</span> 执行flushall命令，也会触发rdb规则</span><br><span class="line"><span class="bullet">3.</span> 退出redis也会产生rrdb文件</span><br><span class="line">---&gt; 如何恢复，</span><br><span class="line"><span class="code">将rdb文件放在redis的启动目录下，启动的时候就会自动进行恢复了。</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>优点：</strong>适合大规模的数据恢复，对数据完整性要求不高</p><p><strong>缺点：</strong>需要一定的时间间隔进行操作，如果意外宕机最后一次的数据就丢失了；fork进程会占用一定的内容空间。</p></blockquote><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><blockquote><p><strong>优点</strong>：每一次修改都同步（默认每秒一次，所以有可能丢失一秒内的数据），从不同步效率最高</p><p><strong>缺点：</strong>相对于数据文件来说，aof远远大于rdb，修复速度也没rdb快（redis默认使用rdb）</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol><li>RDB持久化方式能够在指定时间间隔内对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis协议追加保存每次写的操作到文件的末尾，Redis还能对AOF文件进行后台重写（当大小超过指定大小会保存为另一个文件），使得AOF文件体积不至于过大</li><li>==只做缓存，如果你只希望数据在服务器运行的时候存在，可以不使用持久化==</li><li>同时开启两种持久化：<ul><li>重启的时候会优先载入aof文件来恢复数据，通常aof保存的数据比rdb要完整</li><li>既然优先使用aof且完整性更高，那要不要只使用aof呢？ 不要，rdb更适合于备份数据库，快速恢复数据库，开启后可用作备份手段以防万一。</li></ul></li><li>性能建议：<ul><li>因为RDB更适合做后备手段，建议只在Slave上持久化RDB文件（可以只保留save 900 1这个规则）</li><li>如果EnableAOF，好处是在最恶劣的情况下只丢失不超过两秒的数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认是64M太小了，可以设置到5G以上，默认超过原大小100%大小  重写可以改到适当的数值。</li><li>如果不Enable AOF，仅靠Master-Slave Repllcation 实现高可用性也可以省掉一大笔的IO，也减少了rewrite时带来的系统波动，代价是如果Master、Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master、Slave中的RDB文件，载入比较新的那个，微博采用的就是这种架构。</li></ul></li></ol><p>Redis发布订阅</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分别启动两个客户端cli，一个发布，一个订阅，一边发送了另一边就可以接收到发送的消息</span><br><span class="line">cli01：   subscribe fenda<span class="comment">#订阅一个频道</span></span><br><span class="line">cli02： publish   fenda   <span class="string">&quot;hi xiaohong&quot;</span><span class="comment">#发布一个频道和消息</span></span><br></pre></td></tr></table></figure><p>使用场景：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 实时消息系统（网站的消息推送）</span><br><span class="line">2. 实时聊天（频道聊天室，将消息回显给所有人）</span><br><span class="line">3. 订阅，关注系统</span><br></pre></td></tr></table></figure><h2 id="Redis的主从复制："><a href="#Redis的主从复制：" class="headerlink" title="Redis的主从复制："></a>Redis的主从复制：</h2><p><strong>==数据复制是单向的，只能由主节点到从节点。Master写为主，Slave读为主。==</strong></p><p>且一个主节点可以有多个从节点，一个从节点只有一个主节点</p><blockquote><p><strong>优势：</strong></p><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务（即写redis数据时连接主节点，读时连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点提高读负载，可以大大提高redis服务器的并发量</li><li>高可用（集群）：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是redis高可用的基础。</li></ol></blockquote><blockquote><p><strong>使用场景分析</strong>：（一般1主3从）</p><ol><li>从结构上，单个redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大</li><li>从容量上，单个redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存当做redis存储内存，一般来说，==单台==redis最大使用内存==不应超过20G==</li></ol></blockquote><h3 id="单机环境配置"><a href="#单机环境配置" class="headerlink" title="单机环境配置"></a>单机环境配置</h3><p>只配置从库，不配置主库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6279&gt; info replication                    <span class="comment">#查看当前库的信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment">#角色： master</span></span><br><span class="line">connected_slaves:0<span class="comment"># 没有从机</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 将配置文件复制若干份，对其中的后台守护进程，rdb文件名，pid文件名，和端口号以及dump.rdb的名字分别进行修改，我的改成了6279  6280 6281，准备79设置为主节点其他从节点。</span><br><span class="line">2. 启动6279的服务和cli，查看info如下</span><br><span class="line">127.0.0.1:6279&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master     <span class="comment">#角色 master</span></span><br><span class="line">connected_slaves:0 <span class="comment">#没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:91f73191336f538185625e1359b3b8dd295fa973</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">3. 启动所有的机器,分别不同的服务器和端口（如下）</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/05/971vEGO83F4PrZW.png" alt="image-20210305092438759"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3. 启动后查看配置</span><br><span class="line">127.0.0.1:6281&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment">#还没有变成从机，默认一开始都是主</span></span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">4. 配置</span><br></pre></td></tr></table></figure><h3 id="Docker搭建redis集群"><a href="#Docker搭建redis集群" class="headerlink" title="Docker搭建redis集群"></a>Docker搭建redis集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 分别创建三个容器</span></span><br><span class="line">docker run --name redis-6379 -p 6379:6379 -d redis redis-server</span><br><span class="line">docker run --name redis-6380 -p 6380:6379 -d redis redis-server</span><br><span class="line">docker run --name redis-6381 -p 6381:6379 -d redis redis-server</span><br><span class="line"><span class="comment">#2. 查看对应的容器内ip地址和端口 docker inspect 028b63e3198c</span></span><br><span class="line">172.17.0.2:6379</span><br><span class="line"><span class="comment">#3.查看它们的主从关系，命令 info replication，发现三台目前都是主</span></span><br><span class="line"><span class="comment">#4.运行80 和81的cli，将它们的主机设置为79对应的内网ip</span></span><br><span class="line"></span><br><span class="line">yb@yangbin:~$ docker <span class="built_in">exec</span> -it redis-6381 redis-cli<span class="comment">#启动cli</span></span><br><span class="line">127.0.0.1:6379&gt; slaveof 172.17.0.2 6379 <span class="comment">#设置它的主机是79</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication<span class="comment">#查看返回信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave<span class="comment">#角色 从机</span></span><br><span class="line">master_host:172.17.0.2<span class="comment">#主机：ip</span></span><br><span class="line">master_port:6379<span class="comment">#主机：端口</span></span><br><span class="line">master_link_status:up<span class="comment">#主机连接状态</span></span><br><span class="line">master_last_io_seconds_ago:5<span class="comment">#上次通信时间：5s前</span></span><br><span class="line"></span><br><span class="line">80也使用相同方法进行配置，然后查看79的信息</span><br><span class="line">info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment">#角色：踧踖</span></span><br><span class="line">connected_slaves:2<span class="comment">#已连接从机：2台</span></span><br><span class="line">slave0:ip=172.17.0.3,port=6379,state=online,offset=266,lag=1 </span><br><span class="line">slave1:ip=172.17.0.4,port=6379,state=online,offset=266,lag=1</span><br><span class="line">master_replid:7ebe88825894f94d2458536a01831ca02367761f  </span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line"></span><br><span class="line"><span class="comment">#5. 主从复制，一主二从搭建完成。</span></span><br></pre></td></tr></table></figure><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主机写，从机读</span></span><br><span class="line">如果用从机执行<span class="built_in">set</span>命令，会报错提示 ：READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string">#主机断开，从机仍然连接，但只能读不能写</span></span><br><span class="line"><span class="string">如果使用命令行配置的主从，机器重启会全部恢复成主机，但如果重新变成从机便可以再获取值</span></span><br></pre></td></tr></table></figure><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a><strong>主从复制原理</strong></h3><ul><li>Slave启动成功连接到master后会发送一个sync的同步命令</li><li>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据的命令，在后台执行完毕后，master将传送整个数据文件到Slave，并完成一次完全同步</li><li><strong>全量复制</strong>：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</li><li><strong>增量复制</strong>：Master将新的修改命令依次传给slave，进行同步，一旦断开后==重==新==连==接到master就会==强制==执行一次==全量==复制。</li></ul><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>在主从集群的基础上配置哨兵模式来进行监控和自动选主操作。</p><p>哨兵集群需要自己搭一下。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>redis缓存中没有，数据库也没有</p><h3 id="解决1：布隆过滤器"><a href="#解决1：布隆过滤器" class="headerlink" title="解决1：布隆过滤器"></a>解决1：布隆过滤器</h3><p>是一种数据结构，对所有可能查询的参数以hash的形式存储，在控制层先进性校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p><h3 id="解决2：缓存空对象"><a href="#解决2：缓存空对象" class="headerlink" title="解决2：缓存空对象"></a>解决2：缓存空对象</h3><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存在的问题：</span><br><span class="line"><span class="bullet">1.</span> 需要大量的空间缓存空值</span><br><span class="line"><span class="bullet">2.</span> 空值设置了过期时间，会存在一定时间缓存层和存储层数据窗口不一致，对一致性要求高的业务有影响</span><br></pre></td></tr></table></figure><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>高频热点，同key一直被访问，在key过期的瞬间请求落到数据库造成崩溃。</p><p><strong>解决：热点key永不过期</strong></p><p><strong>解决2：分布式所（互斥锁）</strong></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>请求量较大，某些key忽然过期导致请求落到数据库致使崩溃，又进一步引发大量崩溃</p><p><strong>解决1：redis高可用，异地多活</strong></p><p><strong>解决2：限流降级，缓存失效后对key加锁或限流</strong></p><p><strong>解决3：数据预热（访问前预加载数据到缓存中，将过期时间设置的尽量分散）</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-note</title>
      <link href="2021/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_note/"/>
      <url>2021/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_note/</url>
      
        <content type="html"><![CDATA[<p>1.概述</p><p>常见设计模式有23种</p><p>2.oop七大原则</p><ul><li><strong>开闭原则</strong>：对扩展开放，对修改关闭</li><li><strong>里氏替换原则</strong>：集成必须确保超类所拥有的性质在子类中仍然成立</li><li><strong>依赖倒置原则</strong>：药面向接口编程，不面向实现编程</li><li><strong>单一职责原则</strong>：控制类的粒度大小、将对象解耦、提高其内聚性</li><li><strong>迪米特法则</strong>：只与你的直接朋友交谈，不跟“陌生人”说话</li><li><strong>合成复用原则</strong>：尽量先是纯色组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dockerNote</title>
      <link href="2021/03/01/dockerNote/"/>
      <url>2021/03/01/dockerNote/</url>
      
        <content type="html"><![CDATA[<p>docker和虚拟机的区别：</p><ul><li>虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统中安装和运行软件</li><li>容器中应用直接运行在宿主机的内核，容器是没有自己的内核的，也没有虚拟我们的硬件，所以轻便</li><li>每个容器之间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响。</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="comment">#运行镜像hello-world</span></span><br><span class="line">docker run hello-world</span><br><span class="line">如果提示unable to find images的话会自动去pull这个镜像，直到直到提示Hello from Docker表示镜像拉取成功，</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不需要docker了进行卸载的话</span></span><br><span class="line"><span class="comment">#1 卸载依赖</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="comment">#2 删除资源（docker的默认工作目录）</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>:[<span class="string">&quot;https://qiyb9988.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/01/ONcMK7mLZy6VzPe.png" alt="image-20210301145044860"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>如何工作：</p><p>Docker是一个CS结构的系统，Docker的守护进程运行在主机上，通过socket从客户端访问，DocketServer接收到Docker-Client的指令，就会执行这个命令</p><p>为什么docker比虚拟机更快</p><ol><li><p>docker有着比虚拟机更少的抽象层</p></li><li><p>docker利用的是宿主机的内核，vm需要GuestOS<img src="https://i.loli.net/2021/03/01/wkIArOqnC46zDej.png" alt="image-20210301150019104"></p><p>所以，在新建一个容器时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载GuestOS，分钟级别，而docker是利用宿主机的操作系统，省略了复杂的过程，秒级别</p></li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version     <span class="comment">#版本信息</span></span><br><span class="line">docker info        <span class="comment">#显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span>  <span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="docker-images-查看所有本地的主机上的镜像"><a href="#docker-images-查看所有本地的主机上的镜像" class="headerlink" title="docker images #查看所有本地的主机上的镜像"></a><strong>docker images</strong> #查看所有本地的主机上的镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yb@yanling:~$ docker images</span><br><span class="line">REPOSITORY      TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">bestwu/wechat   latest    dc95baea4912   7 weeks ago     864MB</span><br><span class="line">hello-world     latest    bf756fb1ae65   14 months ago   13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment">#解释</span></span><br><span class="line">REPOSITORY   镜像的仓库源</span><br><span class="line">TAG     镜像的标签</span><br><span class="line">IMAGE ID  镜像的id</span><br><span class="line">CREATED      镜像的创建时间</span><br><span class="line">SIZE         镜像的大小</span><br><span class="line"></span><br><span class="line"><span class="comment">#可选项</span></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             <span class="comment">#列出所有的镜像</span></span><br><span class="line">  -q, --quiet           <span class="comment">#只显示镜像的id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="docker-search-搜索docker镜像"><a href="#docker-search-搜索docker镜像" class="headerlink" title="docker search  #搜索docker镜像"></a><strong>docker search</strong>  <strong>#搜索docker镜像</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker search mysql</span></span><br><span class="line">yb@yangbin:~$ docker search --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">Search the Docker Hub <span class="keyword">for</span> images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="docker-pull-下载镜像"><a href="#docker-pull-下载镜像" class="headerlink" title="docker pull    #下载镜像"></a><strong>docker pull    #下载镜像</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker pull 镜像名 [:tag]</span></span><br><span class="line">yb@yangbin:~$ docker pull mysql</span><br><span class="line">Using default tag: latest  <span class="comment">#如果不写tag，默认下载最新版</span></span><br><span class="line">latest: Pulling from library/mysql  </span><br><span class="line">a076a628af6f: Pull complete  <span class="comment">#分层下载，docker image的核心， 联合文件系统</span></span><br><span class="line">f6c208f3f991: Pull complete </span><br><span class="line">88a9455a9165: Pull complete </span><br><span class="line">406c9b8427c6: Pull complete </span><br><span class="line">7c88599c0b25: Pull complete </span><br><span class="line">25b5c6debdaf: Pull complete </span><br><span class="line">43a5816f1617: Pull complete </span><br><span class="line">1a8c919e89bf: Pull complete </span><br><span class="line">9f3cf4bd1a07: Pull complete </span><br><span class="line">80539cea118d: Pull complete </span><br><span class="line">201b3cad54ce: Pull complete </span><br><span class="line">944ba37e1c06: Pull complete </span><br><span class="line">Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c <span class="comment">#签名</span></span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest  <span class="comment">#真实地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面命令等价于</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker pull mysql:5.7</span></span><br><span class="line">yb@yangbin:~$ docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">a076a628af6f: Already exists   <span class="comment">#区别于上面的下载完整，这里显示的已经存在，联合文件系统的运用</span></span><br><span class="line">f6c208f3f991: Already exists </span><br><span class="line">88a9455a9165: Already exists </span><br><span class="line">406c9b8427c6: Already exists </span><br><span class="line">7c88599c0b25: Already exists </span><br><span class="line">25b5c6debdaf: Already exists </span><br><span class="line">43a5816f1617: Already exists </span><br><span class="line">1831ac1245f4: Pull complete </span><br><span class="line">37677b8c1f79: Pull complete </span><br><span class="line">27e4ac3b0f6e: Pull complete </span><br><span class="line">7227baa8c445: Pull complete </span><br><span class="line">Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure><h4 id="docker-rmi-删除镜像"><a href="#docker-rmi-删除镜像" class="headerlink" title="docker rmi 删除镜像"></a><strong>docker rmi 删除镜像</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 容器id      <span class="comment">#删除指定容器</span></span><br><span class="line">docker rmi -f 容器id 容器id  <span class="comment">#删除多个容器</span></span><br><span class="line">docker rmi -f ￥&#123;docker images -aq&#125;  <span class="comment">#删除全部的容器</span></span><br></pre></td></tr></table></figure><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><blockquote><p>说明：有了镜像才可以创建容器，linux，下载一个centos镜像测试学习</p></blockquote><h4 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数说明</span></span><br><span class="line">-name=<span class="string">&quot;Name&quot;</span>    容器名字  tomcat01   tomcat02   用来区分容器</span><br><span class="line">-d              后台方式运行</span><br><span class="line">-it             使用交互方式运行，进入容器查看内容</span><br><span class="line">-p</span><br><span class="line">-p主机端口：容器端口（常用）</span><br><span class="line">-p      ip：主机端口：容器端口</span><br><span class="line">        -p容器端口</span><br><span class="line">        容器端口</span><br><span class="line">-P随机指定端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试 启动并进入容器</span></span><br><span class="line">yb@yangbin:~$ docker images</span><br><span class="line">REPOSITORY      TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">mysql           5.7       a70d36bc331a   5 weeks ago     449MB</span><br><span class="line">centos          latest    300e315adb2f   2 months ago    209MB</span><br><span class="line">hello-world     latest    bf756fb1ae65   14 months ago   13.3kB</span><br><span class="line">yb@yangbin:~$ docker run -it centos /bin/bash</span><br><span class="line">[root@cb57e4f2755c /]<span class="comment"># ls  #镜像内部的目录也是一个类似于服务器的目录</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker ps 命令</span></span><br><span class="line"> 空    <span class="comment">#列出当前正在运行的容器</span></span><br><span class="line">-a<span class="comment">#列出全部容器（包括在运行和未运行）</span></span><br><span class="line">-n=？    <span class="comment">#显示最近创建的？个容器（？处写数字，列出最近创建的？个容器）</span></span><br><span class="line">-q<span class="comment">#只显示容器的编号</span></span><br></pre></td></tr></table></figure><h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>         <span class="comment">#直接退停止出容器</span></span><br><span class="line">Ctrl +P +Q   <span class="comment">#容器不停止退出</span></span><br></pre></td></tr></table></figure><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 镜像id                <span class="comment">#删除指定容器,运行中的需要使用 -f删除</span></span><br><span class="line">docker rm -f $(docker ps -aq)  <span class="comment">#删除全部容器</span></span><br><span class="line">docker ps -a -q|xargs docker rm<span class="comment">#删除全部容器</span></span><br></pre></td></tr></table></figure><h4 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id    <span class="comment">#启动容器</span></span><br><span class="line">docker restart 容器id  <span class="comment">#重启容器</span></span><br><span class="line">docker stop 容器id <span class="comment">#停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器id     <span class="comment">#强制停止当前的容器</span></span><br></pre></td></tr></table></figure><h3 id="docker的其他常用命令"><a href="#docker的其他常用命令" class="headerlink" title="docker的其他常用命令"></a>docker的其他常用命令</h3><h4 id="问题1：容器以后台方式启动后自动关闭"><a href="#问题1：容器以后台方式启动后自动关闭" class="headerlink" title="问题1：容器以后台方式启动后自动关闭"></a>问题1：容器以后台方式启动后自动关闭</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 容器名 <span class="comment">#启动后用docker ps查看发现容器已经被关闭了</span></span><br><span class="line"><span class="comment">#因为：容器后台运行，必须要有一个前台进程，docker发现没有前台应用，就会自动停止</span></span><br></pre></td></tr></table></figure><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs -tf --tail 10 bfdc57ff20d2 <span class="comment">#显示容器bfdc57ff20d2的最近十行的实时日志</span></span><br><span class="line"></span><br><span class="line">docker logs --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h4 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top bfdc57ff20d2 <span class="comment">#显示容器的uid pid等等信息</span></span><br></pre></td></tr></table></figure><h4 id="查看镜像的元数据"><a href="#查看镜像的元数据" class="headerlink" title="查看镜像的元数据"></a>查看镜像的元数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect bfdc57ff20d2</span><br><span class="line"><span class="comment">#显示容器的id，创建时间，位置，参数，进程id，父进程id，容器名字，配置环境，网络信息</span></span><br></pre></td></tr></table></figure><h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#日常，我们的容器都是一直在后台运行的，当需要查看并修改容器的时候如何进入：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方式1           #进入容器并开启一个新的终端，开始新的操作（常用）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 60a68e7d2b37 /bin/bash</span><br><span class="line"><span class="comment">#方式2   #进入容器正在执行的终端，继续正在执行的操作，不开启新的终端</span></span><br><span class="line">docker attach 容器id</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://i.loli.net/2021/03/01/iTxLHhoX6wAQMjv.png" alt="docker"></p><p><img src="https://i.loli.net/2021/03/01/l6OcmbZyhNuBWQj.png" alt="docker命令1"></p><p><img src="https://i.loli.net/2021/03/01/fm7MnW8UBEo9RdP.png" alt="docker命令2"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>部署nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.用search搜索镜像（推荐使用dockerhub可以查看images的详细信息）</span><br><span class="line">2.拉取镜像</span><br><span class="line">3.以后台的方式启动容器并将端口进行映射</span><br><span class="line">docker run -d --name nginx01 -p 3344：80 nginx </span><br><span class="line"><span class="comment"># -d 后台运行</span></span><br><span class="line"><span class="comment"># --name 给容器起别名，nginx01是镜像的别名，</span></span><br><span class="line"><span class="comment"># -p 宿主机端口：容器内部端口    3344是对外暴露的端口，80是内部的端口，</span></span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line">每次修改容器的配置文件需要重新进入容器进行编辑，相对比较麻烦，有没有可能将配置文件路径映射出来直接进行访问------&gt;  数据卷技术</span><br></pre></td></tr></table></figure><p>部署tomcat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.搜索镜像(推荐使用dockerhub查看镜像的详细信息)</span><br><span class="line"></span><br><span class="line">2.拉取镜像</span><br><span class="line"><span class="comment">#官方tomcat的使用</span></span><br><span class="line">docker run -it --rm tomcat:9.0  <span class="comment">#--rm使用完立即删除，主要用于测试，不推荐</span></span><br><span class="line"><span class="comment">#日常使用</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"></span><br><span class="line">3.启动容器并将端口对外映射</span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat</span><br><span class="line"><span class="comment"># -d    以后台的方式运行</span></span><br><span class="line"><span class="comment"># -p    宿主机端口：内部端口</span></span><br><span class="line"><span class="comment"># --name 容器别名</span></span><br><span class="line"><span class="comment"># 镜像名称</span></span><br><span class="line"></span><br><span class="line">4.进入容器</span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat01 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#出现的问题：1.linux命令少了，  2.没有webapps  --》原因：阿里云镜像造成的，默认只保留了最小的镜像，所有不必要的都进行了提出，保证最小可运行环境</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line">每次修改容器的配置文件需要重新进入容器进行编辑，相对比较麻烦，有没有可能将配置文件路径映射出来直接进行访问------&gt;  数据卷技术</span><br></pre></td></tr></table></figure><p>部署ES+Kibana</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#es 暴露的端口很多</span></span><br><span class="line"><span class="comment">#es 十分消耗内存</span></span><br><span class="line"><span class="comment">#es 的数据一般需要放置到安全目录 挂在</span></span><br><span class="line"><span class="comment">#    --net somenetwork ？ 网络的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动es</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看cpu的状态信息</span></span><br><span class="line">docker stats</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止docker</span></span><br><span class="line">docker stop </span><br><span class="line"></span><br><span class="line"><span class="comment">#发现elasticsearch占用内存特别高，增加对内存的限制。。。。修改配置文件，-e，环境配置修改</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> -d ES_JAVA_OPTS<span class="string">&quot;-Xms64m -Xmx512m&quot;</span> elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拓展：使用kibana来连接es，</span><br><span class="line">由于两个都是在docker内部的容器，而容器之间相互隔离，所以无法直接进行通信，但它们都是基于相同的linux服务所以可以考虑内网ip进行转发。？？？？网络相关教程需要看一下</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可视化工具（几乎不用）"><a href="#可视化工具（几乎不用）" class="headerlink" title="可视化工具（几乎不用）"></a>可视化工具（几乎不用）</h2><p>portainer</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="literal">true</span> portainer/portainer</span><br></pre></td></tr></table></figure><p>Rancher（CI/CD再用）</p><h2 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h2><h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><ol><li><p>下载时候看到的一层一层的就是这个，会一次同时加载多个文件系统，但从外面看只有一个文件系统，联合加载会把隔层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p></li><li><p>bootfs（boot file system）：主要包含BootLoader和kernel，BootLoader主要是引导加载kernel，linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs，这一层与我们典型的linux、unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转给内核，此时系统也会卸载bootfs。</p></li><li><p>rootfs（root file system）：在bootfs之上，包含的就是典型Linux系统中的/dev /proc  /bin  /etc 等标准的目录和文件，rootfs就是各种不同的操作系统发行版本，比如ubuntu centos等等（）</p><p>对于一个精简的os，rootfs可以很小，只需要包含最基本的命令，工具和程序就可以了，因为底层直接用host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版本，bootfs基本是一致的，rootfs会有差别，因此不同的发行版本可以公用bootfs。</p></li></ol><h3 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h3><p>在拉取镜像的时候对于别的镜像已经拉取的那一层会显示already exist，只有不存在的才会进行下载。</p><p>所有的docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上创建新的镜像层。</p><p>对于新pull过来的一个镜像会存在一个镜像层，如果运行起来的话那就是一个容器层，如果需要把它打包发给别人运行那就是重新打包成一个镜像进行commit，然后别人再拉取过来进行运行会是一个新的包含你的容器层和镜像层的新的镜像层。</p><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令和git原理类似</span></span><br><span class="line">docker commit -m<span class="string">&quot;提交的描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器id 目标镜像名：[tag]</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.启动一个默认tomcat</span><br><span class="line">2.发现tomcat的webapps中没有文件，所以copy了一个进来</span><br><span class="line">3.将修改完容器通过commit提交为一个新的镜像</span><br></pre></td></tr></table></figure><p>可以使用commit来对当前的镜像进行备份，保存当前的状态。</p><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>只要删除了容器数据就会丢失， 需求：数据持久化，数据可以保存在本地，容器之间可以有一个数据共享的技术。</p><p>卷技术：目录的挂载，将我们容器内的目录挂载到linux上面。</p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接使用命令来挂载</span></span><br><span class="line">docker run -it -v 主机目录：容器内目录 -p</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="comment">#运行并挂载</span></span><br><span class="line">docker run -it -v /home/ceshi:/home centos /bin/bash</span><br><span class="line"><span class="comment">#用inspect查看</span></span><br><span class="line">docker inspect 01493ee7273b</span><br><span class="line"><span class="comment">#里面有个mount模块，记录了卷挂载的相关信息</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/02/cs61KGOrkDZMWtL.png" alt="image-20210302094515337"></p><h4 id="测试：安装Mysql"><a href="#测试：安装Mysql" class="headerlink" title="测试：安装Mysql"></a>测试：安装Mysql</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令</span></span><br><span class="line">-d   后台方式运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v   数据挂载</span><br><span class="line">-e   参数配置（这块配置的是密码）</span><br><span class="line">--name 容器别名</span><br><span class="line">-tag    5.7表示使用的镜像的版本</span><br></pre></td></tr></table></figure><p>即使容器被删除，挂载到本地的数据卷依旧没有被删除。</p><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匿名挂载</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line">不指定宿主机的位置，只对容器中的位置进行指定</span><br><span class="line">通过inspect命令查看卷的位置</span><br><span class="line"><span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;fcf73dbad7a3a3890bcc1c5f432a13e97dd5bd68edbadcd260b212c6ab4c10a6&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/fcf73dbad7a3a3890bcc1c5f432a13e97dd5bd68edbadcd260b212c6ab4c10a6/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/etc/nginx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#具名挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">这里juming前面没有加/表示juming-nginx只是一个名字</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;juming-nginx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/juming-nginx/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/etc/nginx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;z&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">通过inspect命令查看卷的位置</span><br><span class="line"></span><br><span class="line">docker volume ls  <span class="comment">#列出所有卷的信息，然后找到我们的刚才挂载的juming-nginx</span></span><br><span class="line">docker volume inspect juming-nginx <span class="comment">#查看挂在卷的具体信息</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2021-03-02T10:22:52+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/juming-nginx/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;juming-nginx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所有docker容器内的卷没有指定目录的情况下都挂载在==/var/lib/docker/volumes/xxxx/_data==</p><p>通过具名挂载可以很方便的找到一个卷，所以大多数情况使用的是==具名挂载==</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#区分具名挂载和匿名挂载</span></span><br><span class="line">-v  容器内路径          <span class="comment">#匿名挂载</span></span><br><span class="line">-v  卷名：容器内路径     <span class="comment">#具名挂载</span></span><br><span class="line">-v  /宿主机路径：：容器内路径   <span class="comment">#指定路径挂载</span></span><br></pre></td></tr></table></figure><h2 id="dockerFile"><a href="#dockerFile" class="headerlink" title="dockerFile"></a>dockerFile</h2><blockquote><p>dockerFile就是用来构建docker镜像的构建文件，命令脚本。</p><p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个dockerfile文件，名字可以随机，建议使用dockerfile</span></span><br><span class="line"><span class="comment">#文件中的内容</span></span><br><span class="line">FROM centos  <span class="comment">#指令（大写）+参数</span></span><br><span class="line"></span><br><span class="line">VOLUME [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;---end---&quot;</span></span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="comment">#上面的每个命令就是镜像的一层</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/02/SJUnGT8o4ltmEL6.png" alt="image-20210302105627858"></p><h4 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h4><p>==–volumes-from==</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.使用上面自定义的镜像创建容器1</span><br><span class="line">2.使用自定义镜像创建容器2并将卷挂载在容器1   命令如下</span><br><span class="line">docker run -it --name docker01  8c54f316091c</span><br><span class="line">docker run -it --name docker02 --volumes-from docker01  8c54f316091c</span><br><span class="line">将两个容器都放在后台运行后，然后在容器1的volume01中创建任意文件容器二也会包含相同文件</span><br><span class="line">将容器1删除或者停止后发现volume01 02中的文件仍然可以访问，说明几个挂载卷之间的文件是相互备份进行拷贝的</span><br></pre></td></tr></table></figure><h4 id="总结：dockerfile构建步骤："><a href="#总结：dockerfile构建步骤：" class="headerlink" title="总结：dockerfile构建步骤："></a>总结：dockerfile构建步骤：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dockerFile</span>是用来构建<span class="selector-tag">docker</span>镜像的文件！命令参数脚本！</span><br><span class="line"></span><br><span class="line">1.编写一个<span class="selector-tag">dockerfile</span>文件</span><br><span class="line">2<span class="selector-class">.dockerbuild</span> 构建成为一个镜像</span><br><span class="line">3<span class="selector-class">.docker</span> <span class="selector-tag">run</span>运行镜像</span><br><span class="line">4<span class="selector-class">.docker</span> <span class="selector-tag">push</span>发布镜像（<span class="selector-tag">docker</span> <span class="selector-tag">hub</span>、阿里云镜像仓库）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="DokcerFile构建过程："><a href="#DokcerFile构建过程：" class="headerlink" title="DokcerFile构建过程："></a>DokcerFile构建过程：</h4><p><strong>基础知识</strong>：</p><p>1.每个保留关键字（指令）必须是大写</p><p>2.执行从上到下顺序执行</p><p>3.#标识注释</p><p>4.每个指令都会创建提交一个新的镜像层，一层层提交</p><p><img src="https://i.loli.net/2021/03/02/kqpsO8DaTwv1YMH.png" alt="image-20210302113046993"></p><p>发布项目就需要做镜像，需要编写dockerfile文件</p><p>Dockerfile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages： 通过dockerfile构建生成的镜像，最终发布和运行的产品</p><p>docker容器：容器就是镜像运行起来提供服务器</p><h4 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM   <span class="comment">#基础镜像，一切从这里开始构建</span></span><br><span class="line">MAINTAINER <span class="comment">#镜像是谁写的，姓名+邮箱</span></span><br><span class="line">RUN<span class="comment">#镜像构建的时候需要运行的命令</span></span><br><span class="line">ADD<span class="comment">#步骤：tomcat镜像，这个tomcat压缩包就需要add进去</span></span><br><span class="line">WORKDIR<span class="comment">#镜像的工作目录</span></span><br><span class="line">VOLUME<span class="comment">#挂载的目录</span></span><br><span class="line">EXPOSE<span class="comment">#暴露端口配置</span></span><br><span class="line">CMD<span class="comment">#指定容器启动时候运行的命令，只有最后一个命令会生效，可被替代</span></span><br><span class="line">ENTRYPOINT<span class="comment">#指定这个容器启动的时候需要运行的命令，多个命令都可以生效，可追加命令</span></span><br><span class="line">ONBUILD<span class="comment">#当构建一个被继承DockerFile这个时候就会运行ONBUILD的指令，出发指令</span></span><br><span class="line">COPY<span class="comment">#类似于ADD，经文件拷贝到镜像中</span></span><br><span class="line">ENV<span class="comment">#构建的时候设置环境变量</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/02/QdbWtFzqYarLKyh.png" alt="Dockerfile图解"></p><h4 id="练习：创建自己的centos"><a href="#练习：创建自己的centos" class="headerlink" title="练习：创建自己的centos"></a>练习：创建自己的centos</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.先在home目录创建一个文件夹用于存放自己的dockerfile</span><br><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">mkdir mydockerfile</span><br><span class="line">touch mydockerfile-centos</span><br><span class="line">2.编辑dockerfile文件</span><br><span class="line">sudo gedit mydockerfile-centos</span><br><span class="line">内容如下：</span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER larry&lt;fenda.abc@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span>   <span class="comment">#这个目录就是一进入容器pwd的目录</span></span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span><br><span class="line">CMD ceho <span class="string">&quot;---end---&quot;</span></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line">3.进行build构建操作</span><br><span class="line"><span class="comment">#命令 docker build -f dockerfile文件名 -t 镜像名：[tag]</span></span><br><span class="line">docker build -f mydockerfile-centos -t mycentos:0.1 .</span><br><span class="line"></span><br><span class="line">4.测试自己创建的镜像，如下</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/02/SyLtWNGvzXEskrm.png" alt="image-20210302121233384"></p><p>可以使用==docker history  镜像id==查看镜像的变更历史</p><p><strong>对比cmd和entrypoint</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD<span class="comment">#指定容器启动时候运行的命令，只有最后一个命令会生效，如果run容器的时候追加了命令，那容器中默认的bash命令不再执行而转而执行run后面追加的命令，相当于替换了最后一个命令</span></span><br><span class="line">ENTRYPOINT<span class="comment">#指定这个容器启动的时候需要运行的命令，多个命令都可以生效，虽然dockerfile文件中已经有了bash命令但在启动的时候仍然追加了其他命令，相当于可追加命令，</span></span><br></pre></td></tr></table></figure><h4 id="练习tomcat镜像的build"><a href="#练习tomcat镜像的build" class="headerlink" title="练习tomcat镜像的build"></a>练习tomcat镜像的build</h4><ol><li><p>准备镜像文件： tomcat压缩包 jdk压缩包sudo</p></li><li><p>编写DockerFile文件，命名DockerFile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER larry&lt;fenda.abc@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">COPY readme.txt /usr/<span class="built_in">local</span>/readme.txt</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-7.0.108.tar.gz /usr/<span class="built_in">local</span>/</span><br><span class="line">ADD jdk-11.0.10_linux-x64_bin.tar.gz /usr/<span class="built_in">local</span>/</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk-11.0.10</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/<span class="built_in">local</span>/apache-tomcat-7.0.108</span><br><span class="line">ENV CATALINA_BASE /usr/<span class="built_in">local</span>/apache-tomcat-7.0.108</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/lib:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/<span class="built_in">local</span>/apache-tomcat-7.0.108/bin/startup.sh &amp;&amp; tail -F /url/<span class="built_in">local</span>/apache-tomcat-7.0.108/bin/logs/catalina.out</span><br></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正常来说这里可以不用写-f DockerFile，因为命名符合官方要求所以是可以省略的，但我的不行，我就写上了</span></span><br><span class="line">docker build -f DockerFile -t diytomcat .</span><br></pre></td></tr></table></figure></li><li><p>启动镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-d 后台启动</span></span><br><span class="line"><span class="comment">#-p 端口映射</span></span><br><span class="line"><span class="comment">#--name别名</span></span><br><span class="line"><span class="comment">#-v目录挂载（一个发布目录和一个日志目录了）</span></span><br><span class="line"><span class="comment">#tag镜像名字</span></span><br><span class="line">docker run -d -p 9090:8080 --name larrytomcat -v /home/larry/build/tomcat/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/apache-tomcat-7.0.108/webapps/<span class="built_in">test</span> -v /home/larry/build/tomcat/tomcatlogs/:/usr/<span class="built_in">local</span>/apache-tomcat-7.0.108/logs diytomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>访问测试 localhost:9090</p></li><li><p>发布项目（由于做了卷挂载，我们直接在本地编写项目就可以）</p></li></ol><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><blockquote><p>1.<a href="https://hub.docker.com/">dockerhub地址</a> </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">登录账号：</span><br><span class="line">docker login</span><br><span class="line"><span class="comment">#输入用户名和密码</span></span><br><span class="line">推送docker push</span><br></pre></td></tr></table></figure><blockquote><p>2.<a href="https://cr.console.aliyun.com/repository/cn-hangzhou/larry-test/diytomcat/details">阿里云地址</a></p></blockquote><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>进入容器镜像服务</span><br><span class="line"><span class="number">2.</span>创建命名空间，创建镜像仓库</span><br><span class="line"><span class="number">3.</span>根据仓库下面的操作指南进行登录和<span class="keyword">push</span>操作</span><br></pre></td></tr></table></figure><h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h3 id="认识网络"><a href="#认识网络" class="headerlink" title="认识网络"></a>认识网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">yb@yangbin:/opt/deepinwine/tools$ ip addr    <span class="comment">#查看ip</span></span><br><span class="line"><span class="comment">#第1个ip ：lo 本机回环地址</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment">#第2个ip ：内网地址</span></span><br><span class="line">2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether a4:bb:6d:e4:b2:26 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp0s31f6</span><br><span class="line">    inet 192.168.10.18/23 brd 192.168.11.255 scope global dynamic noprefixroute eno1</span><br><span class="line">       valid_lft 17214sec preferred_lft 17214sec</span><br><span class="line">    inet6 fe80::1600:597b:ab8f:60e7/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment">#第3个ip ：xdroid生成的内网地址</span></span><br><span class="line">3: xdroid0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000</span><br><span class="line">    link/ether 54:7b:85:ed:17:23 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.252.1/24 scope global xdroid0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment">#第4个ip ：docker生成的内网的地址       </span></span><br><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:56:95:d0:59 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:56ff:fe95:d059/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1 创建镜像</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line"><span class="comment">#2 查看容器的ip </span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat01 ip addr</span><br><span class="line"><span class="comment">#3 看能否在外面ping通容器内部ip   能</span></span><br><span class="line"><span class="comment">#4 在容器外重新查找网卡    发现多了一个和容器内网卡绑定的网卡</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#容器带来的网卡都是一对一对的，</span></span><br><span class="line"><span class="comment">#evth-pair 就是一堆的虚拟设备接口，它们都是成对出现的，一段连着协议，一段彼此相连</span></span><br><span class="line"><span class="comment">#OpenStack，Docker容器之间的连接，OVS的桥梁，都是使用evth-pair技术</span></span><br></pre></td></tr></table></figure><p>Docker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥docker0.</p><p><img src="https://i.loli.net/2021/03/02/MxTEkuFawQSsW13.png" alt="docker网络"></p><p>个人小结</p>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/02/23/webservice%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/23/webservice%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>入门说明</p><blockquote><p>优缺点：不同语言和平台之间的交互，可以传输对象；但是因为xml文件本身包含了标签，所以传输中会出现许多这种无用的信息。</p></blockquote><p>开发规范</p><ol><li><p>jax-ws</p></li><li><p>jax-rs</p><p>基于restful的开发规范</p></li></ol><p>通讯协议：SOAP（基于jax-ws）</p><p>wsdl说明书</p><p>基于xml文件，里面说明了基于哪些方法，方法的参数和返回参数等信息</p><p>UDDI:</p><p>用来将webservice服务发布到互联网的一种服务</p><p>ApacherCXF框架</p><p>它是webservice的实现框架，集成了许多插件并与springboot进行集成</p><p>Demo实现</p><ol><li><p>创建服务端：</p><p>创建service+webservice注解，创建测试方法，里面用服务工厂先设置服务地址，然后设置服务类，再发布服务，然后进行测试，在网页打开上面设置的地址查看是否显示bingding相关信息，然后在网址后面加？wsdl查看wsdl说明书，</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其中operat就是方法</span><br><span class="line"><span class="deletion">-input 输入参数</span></span><br><span class="line"><span class="deletion">-output 返回值</span></span><br></pre></td></tr></table></figure></li><li><p>客户端远程访问服务端（必须先知道访问的接口地址）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Java代理： 1. 静态代理；  2.动态代理（jdk接口代理、cglib子类代理）]    <span class="variable">$CGLIB123</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  服务接口访问地址：http://localhost:8000/ws/hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建cxf代理工厂</span></span><br><span class="line">JaxWsProxyFactoryBean factory = <span class="keyword">new</span> JaxWsProxyFactoryBean();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  设置远程访问服务端地址</span></span><br><span class="line">factory.setAddress(<span class="string">&quot;http://localhost:8000/ws/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  设置接口类型</span></span><br><span class="line">factory.setServiceClass(HelloService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  对接口生成代理对象</span></span><br><span class="line">HelloService helloService = factory.create(HelloService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  代理对象对象  class com.sun.proxy.$Proxy34       [Java代理： 1. 静态代理；  2.动态代理（jdk接口代理、cglib子类代理）]    $CGLIB123</span></span><br><span class="line">System.out.println(helloService.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程访问服务端方法</span></span><br><span class="line">String content = helloService.sayHello(<span class="string">&quot;Jet&quot;</span>);</span><br><span class="line">System.out.println(content);</span><br></pre></td></tr></table></figure></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/02/23/rocketmq/"/>
      <url>2021/02/23/rocketmq/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/18/PhvMoLxsXCKaUdb.png" alt="image-20210218203324712"></p><p>参考<a href="https://blog.csdn.net/wu4566285/article/details/105906677">地址</a>:我将里面所有的安装地址都放在usr/local目录下</p><p>启动mq</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/rocketmq-4.7.0/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动nameserver</span></span><br><span class="line">nohup sh mqnamesrv &gt;/usr/<span class="built_in">local</span>/rocketmq/rocketmq-4.7.0/logs/mqnamesrv.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="comment">## 启动broker</span></span><br><span class="line">nohup sh mqbroker -n localhost:9876 &gt;//usr/<span class="built_in">local</span>/rocketmq/rocketmq-4.7.0/logs/broker.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##查看是否启动成功</span></span><br><span class="line">jps</span><br></pre></td></tr></table></figure><p>停止mq</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh mqshutdown broker</span><br><span class="line">sh mqshutdown namesrv</span><br></pre></td></tr></table></figure><p>安装可视化界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/02/23/rabbitmq-%E5%B7%B2%E5%BC%83%E5%9D%91%E6%9A%82%E6%97%B6%E7%94%A8%E4%B8%8D%E4%B8%8A/"/>
      <url>2021/02/23/rabbitmq-%E5%B7%B2%E5%BC%83%E5%9D%91%E6%9A%82%E6%97%B6%E7%94%A8%E4%B8%8D%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://my.oschina.net/u/2364788/blog/2875902">ubuntu上rabbitmq的安装和启动</a></p><p><a href="https://www.cnblogs.com/williamjie/p/9481774.html">简介入门</a></p><p>启动web管理端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><p>本地地址：<a href="http://localhost:15672/#/">http://localhost:15672/#/</a></p><p>用户名、密码：admin</p></blockquote><p>消息队列的使用过程大概如下：</p><p>（1）客户端连接到消息队列服务器，打开一个channel。<br>（2）客户端声明一个exchange，并设置相关属性。<br>（3）客户端声明一个queue，并设置相关属性。<br>（4）客户端使用binding key，在exchange和queue之间建立好绑定关系。<br>（5）客户端投递消息到exchange。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Toots_2021_Feb_18</title>
      <link href="2021/02/18/Toots-2021-Feb-18/"/>
      <url>2021/02/18/Toots-2021-Feb-18/</url>
      
        <content type="html"><![CDATA[<ul><li>Feb-18</li></ul><hr><ul><li><p>假期结束，硬生生一分一分拖到快迟到才起来，恍恍惚惚到了车站恍恍惚惚等车，看着150的到来莫名其妙上了183，车行一半发现路线错了，将错就错打车竟然提前到了公司。</p></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看日志</title>
      <link href="2021/02/09/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/"/>
      <url>2021/02/09/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一、日志分析，以nginx下的access-log为例"><a href="#一、日志分析，以nginx下的access-log为例" class="headerlink" title="一、日志分析，以nginx下的access.log为例"></a>一、日志分析，以nginx下的access.log为例</h1><blockquote><p>这篇是从微信看到的，其中好多是直接copy过来的，作者微信公众号<a href="https://mp.weixin.qq.com/s/c1QXIeYR0zRrzTXWxFNxCw">地址</a></p></blockquote><h2 id="1-先看日志文件的大小，慎用cat"><a href="#1-先看日志文件的大小，慎用cat" class="headerlink" title="1.先看日志文件的大小，慎用cat"></a>1.先看日志文件的大小，慎用cat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#看大小</span></span><br><span class="line">ls -lh access.log</span><br><span class="line">cat查看的文件如果特别大的话会对线上环境产生影响，</span><br><span class="line"><span class="comment">#如果线上环境看比较大的日志文件的话推荐less</span></span><br><span class="line">less access.log</span><br></pre></td></tr></table></figure><h2 id="2-查看倒数5行"><a href="#2-查看倒数5行" class="headerlink" title="2.查看倒数5行"></a>2.查看倒数5行</h2>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 5 access.log</span><br></pre></td></tr></table></figure><h2 id="3-查看实时日志-会根据操作实时进行输出"><a href="#3-查看实时日志-会根据操作实时进行输出" class="headerlink" title="3.查看实时日志,会根据操作实时进行输出"></a>3.查看实时日志,会根据操作实时进行输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f </span><br></pre></td></tr></table></figure><h2 id="4-PV"><a href="#4-PV" class="headerlink" title="4.PV"></a>4.PV</h2><h3 id="4-1-pv分析"><a href="#4-1-pv分析" class="headerlink" title="4.1-pv分析"></a>4.1-pv分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#page view：访问量，以nginx的access.log为例，既然日志内容是访问记录，name有多少条日志就有多少PV,查看pv</span></span><br><span class="line"></span><br><span class="line">wc -l access.log</span><br></pre></td></tr></table></figure><h3 id="4-2-pv分组"><a href="#4-2-pv分组" class="headerlink" title="4.2-pv分组"></a>4.2-pv分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将日志文件可以按照时间分组，使用工具awk，以这里的access.log为例进行说明，awk 命令默认是以「空格」为分隔符，由于访问时间在日志里的第 4 列，因此可以使用命令把访问时间的信息过滤出来，如下：</span><br><span class="line">awk <span class="string">&#x27;&#123;print ￥4&#125;&#x27;</span> access.log</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/09/BeDMVlazSdH3ZJp.png" alt="未处理"></p><p><img src="https://i.loli.net/2021/02/09/kJxmcptB4nrTN8R.png" alt="按时间分组"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如上图所示，日志中有括号、日期、时间，如果只需要日期可使用substr进行截取：</span><br><span class="line">awk <span class="string">&#x27;&#123;print substr&#123;$4,2,11&#125;&#125;&#x27;</span> access.log | sort | uniq -c</span><br><span class="line">其中，sort排序，uniq -c去重操作是用前一行和后一行进行比较后如果相同保留前一行后面的副本行全部删除，这种操作在执行排序后效果会更好，因此先使用sort让所有重复行相邻</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/09/tPeGhdIi8g1fLpA.png" alt="image-20210209153955009"></p><h2 id="5-UV"><a href="#5-UV" class="headerlink" title="5.UV"></a>5.UV</h2><h3 id="5-1-UV分析"><a href="#5-1-UV分析" class="headerlink" title="5.1-UV分析"></a>5.1-UV分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Uniq Visitor，它代表访问人数，比如公众号的阅读量就是以 UV 统计的，不管单个用户点击了多少次，最终只算 1 次阅读量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#access.log 日志里虽然没有用户的身份信息，但是我们可以用「客户端 IP 地址」来近似统计 UV。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> access.log | sort | uniq | wc -l</span><br><span class="line"><span class="comment">#抓取第一列（第一列是ip），然后排序，然后去重，然后查看记录条数</span></span><br><span class="line">&gt;&gt;2589，标识实际访问用户</span><br></pre></td></tr></table></figure><h3 id="5-2-UV分组"><a href="#5-2-UV分组" class="headerlink" title="5.2-UV分组"></a>5.2-UV分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#按天分组，分析每天的UV，需要过滤的就是日期和ip，命令如下</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print substr($4, 2, 11) &quot; &quot; $1 &#125;&#x27;</span> access.log | sort | uniq</span><br><span class="line"><span class="comment">#先获取日期和ip并用空格分开，然后排序去重，这样就将不重复的日期和ip列了出来，如下</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/09/w5T1BUPibNgrlc7.png" alt="image-20210209155551207"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果需要对当天的 UV 统计，在上面的命令再拼接awk <span class="string">&#x27;&#123;print substr($4, 2, 11) &quot; &quot; $1 &#125;&#x27;</span> access.log | sort | uniq | awk <span class="string">&#x27;&#123;uv[$1]++;next&#125;END</span></span><br><span class="line"><span class="string">&#123;for (ip in uv) print ip, uv[ip]&#125;&#x27;</span> 命令就可以了，结果如下图</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/09/fh8a1eKW7yN6FzL.png" alt="image-20210209160507201"></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk 本身是「逐行」进行处理的，当执行完一行后，我们可以用 <span class="keyword">next</span> 关键字来告诉 awk 跳转到下一行，把下一行作为输入。</span><br><span class="line"></span><br><span class="line">对每一行输入，awk 会根据第 <span class="number">1</span> 列的字符串（也就是日期）进行累加，这样相同日期的 ip 地址，就会累加起来，作为当天的 uv 数量。</span><br><span class="line"></span><br><span class="line">之后的 <span class="keyword">END</span> 关键字代表一个触发器，就是当前面的输入全部完成后，才会执行 <span class="keyword">END</span> &#123;&#125; 中的语句，<span class="keyword">END</span> 的语句是通过 <span class="keyword">foreach</span> 遍历 uv 中所有的 key，打印出按天分组的 uv 数量。</span><br></pre></td></tr></table></figure><h2 id="6-终端分析"><a href="#6-终端分析" class="headerlink" title="6.终端分析"></a>6.终端分析</h2><blockquote><p>nginx 的 access.log 日志最末尾关于 User Agent 的信息，主要是客户端访问服务器使用的工具，可能是手机、浏览器等。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第12列是客户端信息，进行排序，然后去重并统计，r标识逆向，n标识按照数值，所处最终数值的降序排列如下</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print $12&#125;&#x27;</span> access.log | sort | uniq -c | sort -rn</span><br><span class="line">结果如下：</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/09/WRTiNlacbfFeXxK.png" alt="image-20210209161353553"></p><h2 id="7-分析top3的请求"><a href="#7-分析top3的请求" class="headerlink" title="7.分析top3的请求"></a>7.分析top3的请求</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第7列，排序，按数值降序排列，只显示前三个</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span> access.log | sort | uniq -rn | head -n 3</span><br></pre></td></tr></table></figure><h1 id="二、grep"><a href="#二、grep" class="headerlink" title="二、grep"></a>二、grep</h1><blockquote><p>grep 命令是一种强大的文本搜索工具，它能使用正则表达式，按照指定的模式去匹配，并把匹配的行打印出来。需要注意的是，grep 只支持匹配而不能替换匹配的内容，替换的功能可以由 sed 来完成。<a href="https://mp.weixin.qq.com/s/KTyxOEJ4PFZ9p9EW_3eo5Q">参考地址</a></p></blockquote><h2 id="常用总结："><a href="#常用总结：" class="headerlink" title="常用总结："></a>常用总结：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-A：除了匹配行，额外显示该行之后的 N 行</span><br><span class="line">-B：除了匹配行，额外显示该行之前的 N 行</span><br><span class="line">-C：除了匹配行，额外显示该行前后的 N 行</span><br><span class="line">-c：统计匹配的行数</span><br><span class="line">-e：实现多个选项间的逻辑 or 关系</span><br><span class="line">-E：支持扩展的正则表达式-F：相当于 fgrep-i：忽略大小写</span><br><span class="line">-n：显示匹配的行号</span><br><span class="line">-o：仅显示匹配到的字符串</span><br><span class="line">-q：安静模式，不输出任何信息，脚本中常用</span><br><span class="line">-s：不显示错误信息</span><br><span class="line">-v：显示不被匹配到的行</span><br><span class="line">-w：显示整个单词</span><br><span class="line">--color：以颜色突出显示匹配到的字符串</span><br></pre></td></tr></table></figure><p>0.创建实例文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">touch g.txt</span><br><span class="line">gedit g.txt</span><br><span class="line"><span class="comment">#将下面内容copy进去</span></span><br><span class="line">0root:x:0:0:root:/bin/zsh</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">syslog:x:104:108::home/syslog:/bin/<span class="literal">false</span></span><br><span class="line">ntp:x:108:114::/home/ntp:/bin/<span class="literal">false</span></span><br><span class="line">sshd:x:109:65534::sshd:/usr/sbin/nologin</span><br><span class="line"><span class="comment">#查看创建的文件</span></span><br><span class="line">cat g.txt</span><br></pre></td></tr></table></figure><h2 id="1-把以-开头或结尾或包含-的行筛选出来"><a href="#1-把以-开头或结尾或包含-的行筛选出来" class="headerlink" title="1.把以**开头或结尾或包含**的行筛选出来"></a>1.把以**<em>开头或结尾或包含**</em>的行筛选出来</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#包含syslog的行</span></span><br><span class="line">grep <span class="string">&quot;syslog&quot;</span> g.log</span><br><span class="line"><span class="comment">#以syslog开头的行</span></span><br><span class="line">grep <span class="string">&quot;^syslog&quot;</span> g.log</span><br><span class="line"><span class="comment">#以syslog结尾的行</span></span><br><span class="line">grep <span class="string">&quot;syslog$&quot;</span> g.log</span><br></pre></td></tr></table></figure><h2 id="2-把符合条件的行的前面n行，后面n行，或前后n行筛选出来"><a href="#2-把符合条件的行的前面n行，后面n行，或前后n行筛选出来" class="headerlink" title="2.把符合条件的行的前面n行，后面n行，或前后n行筛选出来"></a>2.把符合条件的行的前面n行，后面n行，或前后n行筛选出来</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#包含syslog的行及后面2行</span></span><br><span class="line">grep -A2 <span class="string">&quot;syslog&quot;</span> g.txt</span><br><span class="line"><span class="comment">#包含syslog的行及前面2行</span></span><br><span class="line">grep -B2 <span class="string">&quot;syslog&quot;</span> g.txt</span><br><span class="line"><span class="comment">#包含syslog的前后各一行</span></span><br><span class="line">grep -C1 <span class="string">&quot;syslog&quot;</span> g.txt</span><br></pre></td></tr></table></figure><h2 id="3-过滤包含、或不包含关键词的行"><a href="#3-过滤包含、或不包含关键词的行" class="headerlink" title="3.过滤包含、或不包含关键词的行"></a>3.过滤包含、或不包含关键词的行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#包含syslog并输出行号</span></span><br><span class="line">grep -n <span class="string">&quot;syslog&quot;</span> g.txt</span><br><span class="line"><span class="comment">#不包含syslog并输出行号</span></span><br><span class="line">grep -n -v <span class="string">&quot;syslog&quot;</span> g.txt</span><br></pre></td></tr></table></figure><h2 id="4-查目录中包含关键词的所有文件"><a href="#4-查目录中包含关键词的所有文件" class="headerlink" title="4.查目录中包含关键词的所有文件"></a>4.查目录中包含关键词的所有文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#r表递归  n显示行号  w用单词匹配</span></span><br><span class="line">grep -rnw <span class="string">&quot;syslog&quot;</span> .</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="三、自己的生产环境使用的"><a href="#三、自己的生产环境使用的" class="headerlink" title="三、自己的生产环境使用的"></a>三、自己的生产环境使用的</h1><p>查看刚发生报错的日志信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">docker logs -t --since=<span class="string">&quot;这里是开始时间&quot;</span> --until=<span class="string">&quot;这里是结束时间&quot;</span>  容器名 | grep <span class="string">&#x27;需要检索的内容&#x27;</span>  -C行数</span><br><span class="line"></span><br><span class="line">其中-t标识打印时间，since和until为检索的时间范围，可以不写，行数写数字，就是以要检索的内容为中心，前后多少行</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">p2o容器下，报错“未知错误”前后50行，时间范围是。。。到。。。，使用时间范围是因为同样的报错有很多个，可以用它来缩小时间范围，我在使用时间筛选的时候发现如果不写后面的毫秒值会搜不到内容，不清楚是我使用的docker的原因还是其他原因</span><br><span class="line">当然这里时间筛选也可以只写上开始时间--since，或者直接写--since 30m，查找最近30分钟的，如果加-f的话表查询实时日志</span><br><span class="line"></span><br><span class="line">docker logs -t --since=<span class="string">&quot;2021-02-20T02:39:25.478521314Z&quot;</span> --until=<span class="string">&quot;2021-02-20T02:39:27.478521314Z&quot;</span>  sync_p2o_prod | grep <span class="string">&#x27;未知错误&#x27;</span>  -C50</span><br></pre></td></tr></table></figure><p>查看实时日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail=1000 sync_p2o_test</span><br><span class="line">其中-f表实时 -t表显示时间  --tail表显示实时日志的行数，后面也可以用管道符进行搜索操作  | grep</span><br></pre></td></tr></table></figure><p>查看之前几天</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里其实可以和前面nginx下看<span class="keyword">access</span><span class="number">.</span><span class="built_in">log</span>使用方法基本一样，都是对一个文件进行查看而非是容器了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="2021/01/31/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/31/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考视频:汪文君git实战视频</p><p>如果不知道某个命令的话可以使用下面方法来查询 </p><p>git  命令  –help</p></blockquote><h1 id="1-git的安装以及基本使用"><a href="#1-git的安装以及基本使用" class="headerlink" title="1.git的安装以及基本使用"></a>1.git的安装以及基本使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">git --<span class="built_in">help</span></span><br><span class="line"><span class="comment">#创建文件夹并初始化,先进入你知道的目录</span></span><br><span class="line"><span class="built_in">cd</span> Document/</span><br><span class="line">mkdir gitStudy</span><br><span class="line">mkdir lesson01</span><br><span class="line"><span class="built_in">cd</span> lesson01</span><br><span class="line">git init</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p>创建一个文件并提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello Git&quot;</span> &gt;&gt;a.txt</span><br><span class="line">ls</span><br><span class="line"><span class="comment">#查看刚创建的文件,</span></span><br><span class="line">cat a.txt</span><br><span class="line">git status</span><br><span class="line"><span class="comment">#add .表示添加所有文件到暂存区(index区/unstage区),这是一个虚拟目录，add的作用是对这些文件进行追踪</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment">#进行commit操作,-m 后面写的提交信息，这一步是将文件从暂存区放到本地repository（个人一开始初始化的仓库）中</span></span><br><span class="line">git commit -m <span class="string">&#x27;提交文件a.txt&#x27;</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#创建第二个文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;the second file&quot;</span> &gt;&gt;b.txt</span><br><span class="line">git add b.txt</span><br><span class="line"><span class="comment">#一般我们只有add错了才会进行这一步的操作,将文件从暂存区移除(index区/unstage区)，从虚拟目录移除文件，也就是不再进行追踪操作</span></span><br><span class="line"><span class="comment">#或者用 git reset HEAD b.txt也一样的作用</span></span><br><span class="line">git restore --staged b.txt </span><br><span class="line">git status</span><br><span class="line"><span class="comment">#将所有文件add并commit</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;二次提交&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看提交记录</span></span><br><span class="line"><span class="comment">#查看全部提交记录</span></span><br><span class="line">git <span class="built_in">log</span> </span><br><span class="line"><span class="comment">#查看最近一次的提交记录 （提交人的名字，邮箱等信息）</span></span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提交以后文件的再次修改</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;我想多说一句话试试&quot;</span> &gt;&gt;b.txt</span><br><span class="line">git status</span><br><span class="line"><span class="comment">#和上面一样 git add .暂存 </span></span><br><span class="line"><span class="comment">#放弃上面进行的修改（放弃暂存）</span></span><br><span class="line">git restore b.txt</span><br></pre></td></tr></table></figure><h1 id="2-git的Config配置"><a href="#2-git的Config配置" class="headerlink" title="2.git的Config配置"></a>2.git的Config配置</h1><blockquote><p>配置有三个级别,网上教程都是直接使用的global配置,新手入门建议按照global设置,但如果希望后期使用方便的话更加推荐使用local级别,因为我本身除了公司的git以外我还在使用github操作其他的东西.</p></blockquote><ol><li><p>local：针对当前的目录起作用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#目录 .git/config</span></span><br><span class="line">git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure></li><li><p>global：针对全局的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br><span class="line"><span class="comment">#配置文件所在目录，打开查看 </span></span><br><span class="line">cat ~/.gitconfig</span><br></pre></td></tr></table></figure></li><li><p>system：当期机器的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#目录 /etc/gitconfig</span></span><br><span class="line">git confit --system --list</span><br></pre></td></tr></table></figure></li></ol><p>新建文件夹,进行提交然后进行配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">mkdir lesson02</span><br><span class="line"><span class="built_in">cd</span> lesson02 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is a new file&quot;</span> &gt;&gt;c.txt</span><br><span class="line">git add .git cat</span><br><span class="line">git commit -m <span class="string">&quot;new file&quot;</span></span><br><span class="line"><span class="comment">#上面操作会提示进行全局的config配置设置</span></span><br><span class="line"><span class="comment">#进行设置</span></span><br><span class="line">git config --global user.name <span class="string">&quot;fenda&quot;</span></span><br><span class="line">git confgi --global user.email <span class="string">&quot;fenda.abc@gmail.com&quot;</span></span><br><span class="line"><span class="comment">#查看是否生效,查看列出的是否有用户名和邮箱信息,</span></span><br><span class="line">git config --global --list</span><br><span class="line"><span class="comment">#查看当前commit文件使用的哪个配置信息,可以在提交完成后使用git log查看当前使用的配置信息</span></span><br><span class="line"><span class="comment">#对于非首次提交的文件可以使用git commit -am &quot;this is a commit&quot; 来直接进行add和commit操作，但如果文件是首次commit的话需要先进行add操作才可以</span></span><br></pre></td></tr></table></figure><h1 id="3-git中文件的生命周期"><a href="#3-git中文件的生命周期" class="headerlink" title="3.git中文件的生命周期"></a>3.git中文件的生命周期</h1><p><img src="https://i.loli.net/2021/01/31/SP4z9AWDkLwCgi2.png" alt="2021-01-31_15-06_1"></p><ol><li><p>查看当前的指针指向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p HEAD</span><br><span class="line"><span class="comment">##返回结果如下</span></span><br><span class="line">tree 90afcf12e1b36e564e2daf2448d66ceb91e1a436                               </span><br><span class="line">author fenda &lt;fenda.abc@gmail.com&gt; 1612075100 +0800                         </span><br><span class="line">committer fenda &lt;fenda.abc@gmail.com&gt; 1612075100 +0800   </span><br></pre></td></tr></table></figure></li><li><p>查看当前tree指向的具体文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p 90afcf12e1b36e564e2daf2448d66ceb91e1a436 <span class="comment">#上面的hash结果</span></span><br><span class="line"><span class="comment">#返回具体指针指向的具体文件</span></span><br><span class="line">100644 blob 1709fa9fc0bcf53ac95cbfc77fcfa51a24910aeb    a.txt</span><br></pre></td></tr></table></figure></li><li><p>使用git log查看提交记录，其中HEAD指的是当前的一次提交操作后指针的指向，如果当前是一个空的repository，那么HEAD是不存在的</p></li></ol><h1 id="4-git的delete命令操作"><a href="#4-git的delete命令操作" class="headerlink" title="4.git的delete命令操作"></a>4.git的delete命令操作</h1><p><strong>场景：</strong></p><ol><li><p>场景１:创建了一个文件，没有add，然后你不需要它了，直接删除即可</p></li><li><p>场景２:创建完文件已经进行了add,放入了stage区，但后悔了不应该放进去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将文件从stage区域移除</span></span><br><span class="line">git rm --cached a.txt</span><br><span class="line"><span class="comment">#将文件在移出stage区域的同时,讲文件进行删除</span></span><br><span class="line">git rm -f a.txt</span><br></pre></td></tr></table></figure></li><li><p>场景3: 文件已经commit,然后直接删除了本地文件如何操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用status查看状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#使用命令进行确认删除或者放弃刚才更改</span></span><br><span class="line">git checkout -- c.txt <span class="comment">#放弃刚刚进行的本地删除操作,然后查看status</span></span><br><span class="line">git status</span><br><span class="line">ls</span><br><span class="line"><span class="comment">#发现刚刚使用rm -rf c.txt已经删除的文件又重新进行了恢复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者的话可以进行git reset HEAD将文件放入工作目录,而不在stage区域</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="5-commit相关"><a href="#5-commit相关" class="headerlink" title="5.commit相关"></a>5.commit相关</h1><p>如果新add了一些文件,但是想暂时不add这些文件,让HEAD回到上次的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不推荐</span></span><br><span class="line">git reset HEAD;</span><br><span class="line"><span class="comment">#操作完查看状态发现需要进行add才行,然而这样并不好</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法:强制恢复上次</span></span><br><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><h1 id="6-和其他版本管理软件的对比"><a href="#6-和其他版本管理软件的对比" class="headerlink" title="6.和其他版本管理软件的对比"></a>6.和其他版本管理软件的对比</h1><h1 id="7-分支-branch"><a href="#7-分支-branch" class="headerlink" title="7.分支-branch"></a>7.分支-branch</h1><h1 id="8-alias的使用"><a href="#8-alias的使用" class="headerlink" title="8.alias的使用"></a>8.alias的使用</h1><h1 id="9-git-stash使用详解"><a href="#9-git-stash使用详解" class="headerlink" title="9.git stash使用详解"></a>9.git stash使用详解</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在某个分支编辑了一些代码并且已经add了,但需要切换另一个分支紧急调整另外的代码,为了避免刚编辑的代码在另一个分区可见,这里使用git stash讲代码进行保存操作,放入一个box区域,当另一个分支操作完之后,返回当前分支,使用git apply将保存的代码取出,然后编辑完再进行commit操作</span></span><br><span class="line">git stash</span><br><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p>stash是一个不错的方式,但是对于日常使用而言其实操作一次commit然后在进行分支切换也是可以的,只是相对而言比stash多了一次commit,对大局并无影响</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性学习</title>
      <link href="2021/01/19/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/19/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、-lambda表达式"><a href="#一、-lambda表达式" class="headerlink" title="一、 lambda表达式"></a>一、 lambda表达式</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h2><ol><li><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><strong>()</strong> <strong>小括号</strong>里是<strong>参数</strong>，**{}大括号<strong>里是</strong>方法体<strong>， **-&gt;</strong> 是连接符，意思是<strong>goes to</strong></p></li><li><h3 id="函数式接口（常用四个）"><a href="#函数式接口（常用四个）" class="headerlink" title="函数式接口（常用四个）"></a>函数式接口（常用四个）</h3><p>lambda表达式需要函数式接口的支持(接口中只有一个抽象方法的接口,可以使用注解@FunctionalInterface修饰,用来检查是否是函数式接口)</p></li></ol><h2 id="2-双冒号"><a href="#2-双冒号" class="headerlink" title="2. 双冒号"></a>2. 双冒号</h2><blockquote><p>:: ，把方法当做参数传递到stream中，使stream的每个元素都传入到该方法执行一下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><h1 id="二、stream"><a href="#二、stream" class="headerlink" title="二、stream"></a>二、stream</h1><blockquote><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p><a href="https://blog.csdn.net/y_k_y/article/details/84633001">参考链接</a></p><p>一个java 8的stream是由三部分组成的。数据源，零个或一个或多个中间操作，一个或零个终止操作。</p><p>中间操作是对数据的加工，注意，中间操作是lazy操作，并不会立马启动，需要等待终止操作才会执行。</p><p>终止操作是stream的启动操作，只有加上终止操作，stream才会真正的开始执行。</p></blockquote><h2 id="1-特点："><a href="#1-特点：" class="headerlink" title="1.特点："></a>1.特点：</h2><p>​    1 . 不是数据结构，不会保存数据。</p><p>​    2. 不会修改原来的数据源，它会将操作后的数据保存到另外一个对象中。（保留意见：毕竟peek方法可以修改流中元素）</p><p>​    3. 惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。</p><h2 id="2-分类："><a href="#2-分类：" class="headerlink" title="2.分类："></a>2.分类：</h2><p><img src="https://i.loli.net/2021/01/19/pyFvImUzV1lPX9Y.png" alt="img"></p><ul><li><p>无状态：指元素的处理不受之前元素的影响；</p></li><li><p>有状态：指该操作只有拿到所有元素之后才能继续下去。</p></li><li><p>非短路操作：指必须处理所有元素才能得到最终结果；</p></li><li><p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</p></li></ul><h2 id="3-流的中间操作："><a href="#3-流的中间操作：" class="headerlink" title="3.流的中间操作："></a>3.流的中间操作：</h2><h3 id="3-1筛选与切片"><a href="#3-1筛选与切片" class="headerlink" title="3.1筛选与切片"></a>3.1筛选与切片</h3><ul><li><p>filter：过滤流中的某些元素</p></li><li><p>limit(n)：获取n个元素</p></li><li><p>skip(n)：跳过n元素，配合limit(n)可实现分页</p></li><li><p>distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">14</span>);</span><br><span class="line"> </span><br><span class="line">Stream&lt;Integer&gt; newStream = stream.filter(s -&gt; s &gt; <span class="number">5</span>) <span class="comment">//6 6 7 9 8 10 12 14 14</span></span><br><span class="line">        .distinct() <span class="comment">//6 7 9 8 10 12 14</span></span><br><span class="line">        .skip(<span class="number">2</span>) <span class="comment">//9 8 10 12 14</span></span><br><span class="line">        .limit(<span class="number">2</span>); <span class="comment">//9 8</span></span><br><span class="line">newStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2映射"><a href="#3-2映射" class="headerlink" title="3.2映射"></a>3.2映射</h3><ul><li>map：接受一个函数作为参数，该函数会被应用到每个元素，并将其映射成一个新的元素（将原始数据进行转换存储，提取其中一部分或者将它换一种形式存储）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line"><span class="comment">//将每个元素转成一个新的且不带逗号的元素</span></span><br><span class="line">Stream&lt;String&gt; s1 = list.stream().map(s -&gt; s.replaceAll(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">s1.forEach(System.out::println); <span class="comment">// abc  123</span></span><br><span class="line"></span><br><span class="line">解释：这个接口的使用例子，比如提取了医生的所有的排班信息，但在做映射的时候并不是全部需要，只需要将要用到的日期信息进行提取即可。</span><br></pre></td></tr></table></figure><ul><li>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s3 = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line"> <span class="comment">//将每个元素转化成一个stream</span></span><br><span class="line"> String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"> Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line"> <span class="keyword">return</span> s2;    </span><br><span class="line">&#125;)</span><br><span class="line">s3.forEach(System.out::println); <span class="comment">//a b c 1 2 3    </span></span><br></pre></td></tr></table></figure><h3 id="3-3排序"><a href="#3-3排序" class="headerlink" title="3.3排序"></a>3.3排序</h3><ul><li>sorted():自然排序，流中元素需要实现comparale接口</li><li>sorted(Comparator com)：定制排序，自定义Comparator排序器</li></ul><h3 id="3-4消费"><a href="#3-4消费" class="headerlink" title="3.4消费"></a>3.4消费</h3><ul><li>peek: 如同map，能得到流中的每一个元素，但map接受的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2);</span><br><span class="line"> </span><br><span class="line">studentList.stream()</span><br><span class="line">        .peek(o -&gt; o.setAge(<span class="number">100</span>))</span><br><span class="line">        .forEach(System.out::println);   </span><br><span class="line"> </span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;aa&#x27;</span>, age=<span class="number">100</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;bb&#x27;</span>, age=<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="4流的终止"><a href="#4流的终止" class="headerlink" title="4流的终止"></a>4流的终止</h2><h4 id="4-1-匹配、聚合操作"><a href="#4-1-匹配、聚合操作" class="headerlink" title="4.1 匹配、聚合操作"></a>4.1 匹配、聚合操作</h4><ul><li>allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false</li><li>noneMatch：接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false</li><li>anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false</li><li>findFirst：返回流中第一个元素</li><li>findAny：返回流中的任意元素</li><li>count：返回流中元素的总个数</li><li>max：返回流中元素最大值</li><li>min：返回流中元素最小值</li></ul><h4 id="4-2-规约操作"><a href="#4-2-规约操作" class="headerlink" title="4.2 规约操作"></a>4.2 规约操作</h4><blockquote><p>归约操作可以将流中元素反复结合起来，得到一个值</p></blockquote><p>Optional<T> reduce(BinaryOperator<T> accumulator)：第一次执行时，accumulator 函数的第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第三个元素；依次类推。<br>     T reduce(T identity, BinaryOperator<T> accumulator)：流程跟上面一样，只是第一次执行时，accumulator 函数的第一个参数为 identity，而第二个参数为流中的第一个元素。<br>     <U> U reduce(U identity,BiFunction&lt;U, ? super T, U&gt; accumulator,BinaryOperator<U> combiner)：在串行流 (stream) 中，该方法跟第二个方法一样，即第三个参数 combiner 不会起作用。在并行流 (parallelStream) 中, 我们知道流被 fork join 出多个线程进行执行，此时每个线程的执行流程就跟第二个方法 reduce(identity,accumulator)一样，而第三个参数 combiner 函数，则是将每个线程的执行结果当成一个新的流，然后使用第一个方法 reduce(accumulator)流程进行规约。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经过测试，当元素个数小于24时，并行时线程数等于元素个数，当大于等于24时，并行时线程数为16</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>);</span><br><span class="line"> </span><br><span class="line">Integer v = list.stream().reduce((x1, x2) -&gt; x1 + x2).get();</span><br><span class="line">System.out.println(v);   <span class="comment">// 300</span></span><br><span class="line"> </span><br><span class="line">Integer v1 = list.stream().reduce(<span class="number">10</span>, (x1, x2) -&gt; x1 + x2);</span><br><span class="line">System.out.println(v1);  <span class="comment">//310</span></span><br><span class="line"> </span><br><span class="line">Integer v2 = list.stream().reduce(<span class="number">0</span>,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stream accumulator: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 - x2;</span><br><span class="line">        &#125;,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stream combiner: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 * x2;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(v2); <span class="comment">// -300</span></span><br><span class="line"> </span><br><span class="line">Integer v3 = list.parallelStream().reduce(<span class="number">0</span>,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;parallelStream accumulator: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 - x2;</span><br><span class="line">        &#125;,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;parallelStream combiner: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 * x2;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(v3); <span class="comment">//197474048</span></span><br></pre></td></tr></table></figure><h4 id="4-3-收集操作"><a href="#4-3-收集操作" class="headerlink" title="4.3 收集操作"></a>4.3 收集操作</h4><h1 id="三-、Optional"><a href="#三-、Optional" class="headerlink" title="三 、Optional"></a>三 、Optional</h1><blockquote><p><a href="https://www.cnblogs.com/yw0219/p/7354938.html">参考</a></p></blockquote><ul><li><p>Optional.empty( ): 创建一个空的Optional实例</p></li><li><p>Optional.of(T  t) : 创建一个Optional实例,其中t不能为null,否则会空指针异常</p></li><li><p>☆Optional.ofNullable(T t): 若t不为null,创建Optional实例,否则创建空实例</p><ul><li>ofNullable相当于of和empty两个加起来</li><li>用of（）和ofNullable()可以创建包含值的Optional，区别在于of()会在将null作为值进行传递的时候跑出空指针异常。所以只有确定对象不为null的时候使用of(),其他时候使用ofNullable()</li></ul></li><li><p>☆ifPresent() :判断是否包含值,非空返 true，否则返false; </p></li><li><p>orElseGet(Supplier   s): 如果调用对象包含值的时候返回该值,否则返回Supplier方法调用s返回的值；</p></li><li><p>☆orElse(T t) 方法与 orElseGet 方法相似，不同如果调用对象包含值则返回不包含则直接返回传入的默认值t。</p></li><li><p>☆orElseThrow 如果有值则将其返回，否则抛出<code>Supplier</code>接口创建的异常。</p></li><li><p>☆map(Function f) 如果有值则对其处理,并返回处理后的Optional,否则返回Optional.empty()；</p></li><li><p>flatMap(Function  mapper): 与map相似,要求返回值必须是optional</p><p><img src="https://i.loli.net/2021/02/07/TvfIiy6QNP4LnFu.png" alt="image-20210207160522189"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java8 </tag>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis基本使用及相关注意事项</title>
      <link href="2021/01/13/mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>2021/01/13/mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文档:<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">MyBatis官方文档</a></p></blockquote><h1 id="Mybatis原理图"><a href="#Mybatis原理图" class="headerlink" title="Mybatis原理图"></a>Mybatis原理图</h1><p><img src="https://i.loli.net/2021/01/13/2eYpRIGz673XFur.png" alt="mybatis原理图"></p><h2 id="Mybatis配置文件SqlMapConfig-xml"><a href="#Mybatis配置文件SqlMapConfig-xml" class="headerlink" title="Mybatis配置文件SqlMapConfig.xml"></a>Mybatis配置文件SqlMapConfig.xml</h2><p>properties（属性）</p><ul><li><p>将数据库连接的参数单独配置在，db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。</p></li><li><p><strong>好处：</strong>方便对参数进行统一管理，其它xml可以引用该db.properties</p></li><li><p><strong>特性：</strong> MyBatis 将按照下面的顺序来加载属性：</p><ul><li>在 properties 元素体内定义的属性首先被读取。</li><li>然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。</li><li>最后读取parameterType传递的属性，它会覆盖已读取的同名属性。</li></ul><p><strong>建议：</strong></p><ul><li><p>不要在properties元素体内添加任何属性值，只将属性值定义在properties文件中。</p></li><li><p>在properties文件中定义属性名要有一定的特殊性，如XXXXX.XXXXX.XXXX</p><p><img src="https://i.loli.net/2021/01/13/bjKxQt7Pf8ACa5m.png" alt="这里写图片描述"><img src="https://i.loli.net/2021/01/13/TcbBqAt2WHVpM1J.png" alt="这里写图片描述"></p></li></ul></li></ul><p>typeAliases（类型别名）(<strong>重点</strong>)</p><ul><li><p>单个定义<img src="https://i.loli.net/2021/01/13/l2iBdPm6RqpJueI.png" alt="这里写图片描述"></p></li><li><p>批量定义（常用）<img src="https://i.loli.net/2021/01/13/SLEYoukfCH1ianW.png" alt="这里写图片描述"></p><ul><li>这样在其他地方就可以使用<img src="https://i.loli.net/2021/01/13/2k45zuQoEyiXHTZ.png" alt="这里写图片描述"></li></ul></li></ul><h2 id="Mybatis核心"><a href="#Mybatis核心" class="headerlink" title="Mybatis核心"></a>Mybatis核心</h2><p><strong>Mybatis输入映射（掌握）</strong></p><ul><li>通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型<ul><li>传递pojo的包装对象</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴代码规范总结</title>
      <link href="2021/01/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/"/>
      <url>2021/01/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>电子书PDF版本      <a href="https://github.com/alibaba/p3c">git地址</a>     <a href="https://raw.githubusercontent.com/alibaba/p3c/a471c5f60b39d3ba2c7685a048e59101fcf517d4/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf">下载地址</a></p><p><a href="https://tower.im/teams/694585/repository_documents/10352/">别人整理好的文档</a></p></blockquote><p>以下仅为少部分的摘录,完整版需自行下载查看.</p><ol><li><p><strong>类名</strong>大驼峰:</p><p>例如:ForceCode  /  UserDo / HtmmlDTO  / XmlService  </p></li><li><p><strong>方法名</strong>、<strong>参数名</strong>、<strong>成员变量</strong>、<strong>局部变量</strong>小驼峰:</p><p>例如: localValue  /  getHttpMessage()  /  inputUseriId </p></li><li><p><strong>常量名</strong>强制<strong>大</strong>写,单词间下划线分隔开</p><p>例如: MAX_STOCK_COUNT  /  CACHE_EXRIRED_TIME</p></li><li><p><strong>包名</strong>统一<strong>小</strong>写</p><p>例如: com.alibaba.ei.kunlun.aap.util</p></li><li><p><strong>枚举类名</strong>带上<strong>Enum</strong>后缀,枚举成员名称需要全部<strong>大写</strong>,单词间用下划线隔开.</p><p>例如:  枚举名为ProcessStatusEnumerate的成员明工程: SUCCESS /UNKNOW _REASON</p></li><li><p><strong>大括号内为空</strong>,则写成**{}**,中间无序换行和空格,</p></li><li><p>左小括号和右边相邻字符之间不出现空格;右小括号和左相邻字符间不出现空格;而<strong>左大括</strong>号<strong>前</strong>需要加<strong>空格</strong>;</p></li><li><p>if/for/while/switch/do等<strong>保留字与括号</strong>之<strong>间</strong>必须加<strong>空格</strong></p></li><li><p>任何二目、三目运算符的左右两边都需要加一个空格</p><p>例如:  +  -  *  /  =  &amp;&amp;  等运算符都需满加空格</p></li><li><p><strong>禁用tab缩进</strong>,使用<strong>四个字符</strong>缩进</p></li><li><p><strong>注释</strong>的双斜线与注释内容之间有且仅有<strong>一个空格</strong></p></li><li><p>强制类型转换时,<strong>右括号</strong>与<strong>转换值</strong>之间<strong>不</strong>需要任何<strong>空格</strong>.</p><p>例如: double first = 3.2d;                   int second = (int)first + 2;</p></li><li><p>方法参数在定义和传入时,<strong>多</strong>个<strong>参</strong>数<strong>逗号后面</strong>必须加<strong>空格</strong></p></li><li><p>IDE的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式 , 不要使用 Windows 格式</p></li><li><p><strong>避免</strong>通过一个<strong>类的对象</strong>引用<strong>访问</strong>此类的<strong>静态变量或静态方法</strong>,应该<strong>直接</strong>通过<strong>类名</strong>来访问.</p></li><li><p>所有<strong>整型包装类对象</strong>之间<strong>值的比较</strong>，全部使用 <strong>equals</strong> 方法比较。<br>说明：对于 Integer var = ? 在-128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，<br>会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都<br>会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。</p></li><li><p>日期格式:</p><table><thead><tr><th align="center">年份</th><th align="center">月份</th><th align="center">分钟</th><th align="center">24小时制</th><th align="center">12小时制</th></tr></thead><tbody><tr><td align="center">yyyy</td><td align="center">M</td><td align="center">m</td><td align="center">H</td><td align="center">h</td></tr></tbody></table></li><li><p><strong>不允许</strong>使用: 1. java.sql.Date  2. java.sql.Time 3. java.sql.Timestamp</p></li><li><p>关于hashCode和equals的处理:</p><ol><li>只要覆写equals,就必须覆写hashCode</li><li>因为set存储的不重复对象,依据hashCode和equals进行判断,所以Set存储的对象必须覆写这两种方法</li><li>如果自定义对象作为Map的键,那么必须覆写hashCode和equlas</li></ol></li><li><p>判断集合元素是否为空使用**isEmpty()**方法</p></li><li><p>类、类属性、类方法的注释必须使用<code>/**内容*/</code>格式 </p></li><li><p>方法内单行注释,在被注释语句上另起一行,使用**//**注释,</p></li><li><p>服务器内部重定向使用<strong>forward</strong>,外部重定向使用<strong>URL</strong>统一代理模块生成</p></li><li><p>在进行序列化和反序列化操作的时候，类的serialVersionUID的不能改变，为了避免每次都使用1L这个值，所以在idea中需要将edit-inspections中的serialVersionUID进行勾选。每次生成类的时候会自动进行提示。<img src="https://i.loli.net/2021/02/23/PWeqXIQprKw8cHN.png" alt="image-20210223210504651"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ssh学习记录</title>
      <link href="2021/01/10/ssh%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2021/01/10/ssh%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p>安装ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在bash中输入</span></span><br><span class="line">sudo apt install openssh-client</span><br><span class="line"><span class="comment">#测试是否安装成功,显示版本号</span></span><br><span class="line">ssh -V</span><br></pre></td></tr></table></figure></li><li><p>登录服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以我的云主机为例,其中我的用户名:dc2-user 我的ip地址:117.51.155.221,连接的时候请改成自己的,中间用@进行分隔</span></span><br><span class="line">ssh dc2-user@117.51.155.221</span><br><span class="line"><span class="comment">#输入完之后会提示第一次连接,先输入yes 回车,然后输入用户密码,即可登录成功,发现用户已经变化了</span></span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/01/10/jWcB7OZQiKHlkGw.png" alt="image-20210110180336172" style="zoom:135%;" /><p><img src="https://i.loli.net/2021/01/10/tGaNiOYjIfkpKsV.png" alt="image-20210110180406136"></p></li><li><p>ssh的配置文件</p><ol><li>全局配置文件: <code>/etc/ssh/ssh_config</code></li><li>个人配置文件: <code>~/.ssh/config</code></li></ol></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习</title>
      <link href="2021/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Orcale"><a href="#Orcale" class="headerlink" title="Orcale"></a>Orcale</h1><ol><li><p>nvl(eExpression1,eExpression2)</p><p>用法: 如果eExpression1的计算结果为null,则返回eExpression2;不为null,则返回eExpression1.</p></li><li><p>select * into a from b</p><p>用法: 将表b中的查找的数据记录在表a中</p></li><li><p>:= 和=:的区别</p><p><strong>=：</strong>应该相当于 a = :b 表明b是个绑定变量，需要执行时进行变量绑定<br><strong>:=</strong> 相当于一般编程语言中的 赋值 a := 1 即将 数字1<strong>赋值</strong>给变量 a</p></li><li><p>异常抛出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Err_Item是上面定义好的异常抛出,这里将message的内容进行抛出,存过前面已经进行定义</span><br><span class="line">message :&#x3D; &#39;排班id无效或已取消&#39;;</span><br><span class="line">raise Err_Item</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>decode()函数语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">decode</span>（columnname，值<span class="number">1</span>,翻译值<span class="number">1</span>,值<span class="number">2</span>,翻译值<span class="number">2</span>,...值n,翻译值n,缺省值）</span><br><span class="line"><span class="keyword">From</span> talbename</span><br><span class="line"><span class="keyword">Where</span> …</span><br></pre></td></tr></table></figure><p>主要作用：相当于switch语句，case1，case2……..将查询结果翻译成其他值</p><p>举例：</p><p>现定义一 table 名为 output，其中定义两个 column 分别为 monthid（var 型）和 sale（number 型），若 sale 值 = 1000 时翻译为 D，=2000 时翻译为 C，=3000 时翻译为 B，=4000 时翻译为 A，如是其他值则翻译为 Other：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> monthid , <span class="keyword">decode</span> (sale,<span class="number">1000</span>,<span class="string">&#x27;D&#x27;</span>,<span class="number">2000</span>,<span class="string">&#x27;C&#x27;</span>,<span class="number">3000</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">4000</span>,<span class="string">&#x27;A&#x27;</span>,’Other’) sale <span class="keyword">from</span> <span class="keyword">output</span></span><br></pre></td></tr></table></figure></li><li><p>NVL(EXPR1,EXPR2)</p></li></ol><p>　　若 EXPR1 是 NULL, 则返回 EXPR2, 否则返回 EXPR1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NAME</span>,NVL(TO_CHAR(COMM),<span class="string">&#x27;NOT APPLICATION&#x27;</span>) <span class="keyword">FROM</span> TABLE1;</span><br></pre></td></tr></table></figure><pre><code>如果用到 decode 函数中：</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> monthid,<span class="keyword">decode</span>(nvl(sale,<span class="number">6000</span>),<span class="number">6000</span>,<span class="string">&#x27;NG&#x27;</span>,<span class="string">&#x27;OK&#x27;</span>) <span class="keyword">from</span> <span class="keyword">output</span>;</span><br></pre></td></tr></table></figure><ol><li><p>sign()</p><p>sign() 函数根据某个值是 0、正数还是负数，分别返回 0、1、-1，</p><p>用如下的 SQL 语句取较小值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> monthid,<span class="keyword">decode</span>(<span class="keyword">sign</span>(sale<span class="number">-6000</span>),<span class="number">-1</span>,sale,<span class="number">6000</span>) <span class="keyword">from</span> <span class="keyword">output</span>;</span><br></pre></td></tr></table></figure></li><li><p>&lt;&gt; 0</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不等于0的判断</span></span><br><span class="line">if a &lt;&gt; 0 then raise Err_Item</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> orcale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu软件安装&amp;遇到的问题</title>
      <link href="2021/01/03/ubuntu%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85&amp;%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/01/03/ubuntu%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85&amp;%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 我将自己下载的文件已经放在了对应的软件包里,如果要安装优先找软件包,找不到再去别的地方.</p><p>为了方便管理,我将下载的安装文件创建了一个<code>soft</code>文件夹进行保存,将解压后的软件放在<code>/usr/local/</code>目录中,将maven tomcat jdk这种环境类的放在<code>/usr/local/envir</code>中.</p></blockquote><h1 id="1-不同软件的安装和卸载方式"><a href="#1-不同软件的安装和卸载方式" class="headerlink" title="1.不同软件的安装和卸载方式"></a>1.不同软件的安装和卸载方式</h1><h2 id="1-1-deb文件安装"><a href="#1-1-deb文件安装" class="headerlink" title="1.1 deb文件安装"></a>1.1 deb文件安装</h2><p>dpkg -i 文件名</p><ol><li><p>如果提示<strong>依赖关系问题仍未被配置</strong>,可以使用    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt autoremove</span><br><span class="line">sudo apt --fix-broken install</span><br><span class="line">还有一种情况就是这个软件已经安装了.</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>dpkg 被中断，您必须手工运行 sudo dpkg –configure -a 解决</p><p>此问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主要原因应该是/var/lib/dpkg/updates 文件夹里面的资料有错误，使得更新软件的程序出现错误，所以得把它们完全删除，通过sudo apt-get update这个指令会重新建立这些资料，使用sudo apt-get upgrade更新你的电脑里面已安装的软件的明细，根据软件的明细更新软件到最新版。</span></span><br><span class="line"><span class="comment">#英文好的可以看看[这篇文章](http://ubuntuforums.org/archive/index.php/t-941125.html)</span></span><br><span class="line"></span><br><span class="line">sudo rm /var/lib/dpkg/updates/*</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li><li><p>E: 仓库 “<a href="http://ppa.launchpad.net/webupd8team/java/ubuntu">http://ppa.launchpad.net/webupd8team/java/ubuntu</a> eoan Release” 没有 Release 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除对应的ppa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 切换到sources.list.d目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/apt/sources.list.d</span><br><span class="line"><span class="comment">#2. 使用ls查看所有的,然后将刚才报错的删除</span></span><br><span class="line">ls</span><br><span class="line">rm -rf webupd8team-ubuntu-java-eoan.list </span><br></pre></td></tr></table></figure></li><li><p>如果数据源出现了各种错误，最根本的办法就是直接替换数据源<a href="https://mirrors.ustc.edu.cn/repogen/">网站</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看自己的系统版本：</span></span><br><span class="line">cat /etc/issue</span><br><span class="line"><span class="comment">#根据自己的版本复制对应的文件：</span></span><br><span class="line"><span class="comment">#使用上面的网站</span></span><br><span class="line"><span class="comment">#打开系统文件进行修改：</span></span><br><span class="line">sudo gedit /etc/apt/sources.list</span><br><span class="line"><span class="comment">#好像可以使用下面命令进行配置文件生效（我也不确定）</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>然后可以使用下面的命令进行各种服务的检测和更新操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>使用下面命令进行系统更新检查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-manager -<span class="built_in">cd</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>如果修改了数据源然后出现“无法用该源进行更新，所以禁用了该源”或者“没有release文件”导致大量的报错的话如何修复：</p><p><img src="https://i.loli.net/2021/01/03/sEKeyAqTpriWuvB.png" alt="image-20210103025909206"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改/etc/apt/sources.list文件</span></span><br><span class="line">sudo  gedit  /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#进去全删了，改成下面的</span></span><br><span class="line"><span class="comment">#deb cdrom:[Ubuntu 20.04 LTS _Focal Fossa_ - Release amd64 (20200423)]/ focal main restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span></span><br><span class="line"><span class="comment"># newer versions of the distribution.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ focal main restricted</span><br><span class="line"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal main restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Major bug fix updates produced after the final release of the</span></span><br><span class="line"><span class="comment">## distribution.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ focal-updates main restricted</span><br><span class="line"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates main restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span></span><br><span class="line"><span class="comment">## team. Also, please note that software in universe WILL NOT receive any</span></span><br><span class="line"><span class="comment">## review or updates from the Ubuntu security team.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ focal universe</span><br><span class="line"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal universe</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ focal-updates universe</span><br><span class="line"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates universe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu </span></span><br><span class="line"><span class="comment">## team, and may not be under a free licence. Please satisfy yourself as to </span></span><br><span class="line"><span class="comment">## your rights to use the software. Also, please note that software in </span></span><br><span class="line"><span class="comment">## multiverse WILL NOT receive any review or updates from the Ubuntu</span></span><br><span class="line"><span class="comment">## security team.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ focal multiverse</span><br><span class="line"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal multiverse</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ focal-updates multiverse</span><br><span class="line"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository may not have been tested as</span></span><br><span class="line"><span class="comment">## extensively as that contained in the main release, although it includes</span></span><br><span class="line"><span class="comment">## newer versions of some applications which may provide useful features.</span></span><br><span class="line"><span class="comment">## Also, please note that software in backports WILL NOT receive any review</span></span><br><span class="line"><span class="comment">## or updates from the Ubuntu security team.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Uncomment the following two lines to add software from Canonical&#x27;s</span></span><br><span class="line"><span class="comment">## &#x27;partner&#x27; repository.</span></span><br><span class="line"><span class="comment">## This software is not part of Ubuntu, but is offered by Canonical and the</span></span><br><span class="line"><span class="comment">## respective vendors as a service to Ubuntu users.</span></span><br><span class="line"><span class="comment"># deb http://archive.canonical.com/ubuntu focal partner</span></span><br><span class="line"><span class="comment"># deb-src http://archive.canonical.com/ubuntu focal partner</span></span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu focal-security main restricted</span><br><span class="line"><span class="comment"># deb-src http://security.ubuntu.com/ubuntu focal-security main restricted</span></span><br><span class="line">deb http://security.ubuntu.com/ubuntu focal-security universe</span><br><span class="line"><span class="comment"># deb-src http://security.ubuntu.com/ubuntu focal-security universe</span></span><br><span class="line">deb http://security.ubuntu.com/ubuntu focal-security multiverse</span><br><span class="line"><span class="comment"># deb-src http://security.ubuntu.com/ubuntu focal-security multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This system was installed using small removable media</span></span><br><span class="line"><span class="comment"># (e.g. netinst, live or single CD). The matching &quot;deb cdrom&quot;</span></span><br><span class="line"><span class="comment"># entries were disabled at the end of the installation process.</span></span><br><span class="line"><span class="comment"># For information about how to configure apt package sources,</span></span><br><span class="line"><span class="comment"># see the sources.list(5) manual.</span></span><br></pre></td></tr></table></figure></li><li><p>由于已经达到 MaxReports 限制，没有写入 apport 报告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/dpkg  </span><br><span class="line">sudo mv info/ info-bak  </span><br><span class="line">sudo mkdir info  </span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install -f  </span><br><span class="line"></span><br><span class="line"><span class="comment">#然后恢复info-bak</span></span><br><span class="line">sudo mv info/* info-bak/  </span><br><span class="line">sudo rm -rf info  </span><br><span class="line">sudo mv info-bak/ info  </span><br></pre></td></tr></table></figure></li></ol><h2 id="1-2-appimages安装"><a href="#1-2-appimages安装" class="headerlink" title="1.2 appimages安装"></a>1.2 appimages安装</h2><p>右键属性,修改权限为读写可执行,然后直接运行,这个软件相当于win中的绿色软件自带了运行环境,无需安装.</p><p>对于这种类型的软件如果需要每次都启动就很麻烦,所以可以用它的管理工具<strong>AppimageLancher</strong></p><h2 id="1-3-rpm安装"><a href="#1-3-rpm安装" class="headerlink" title="1.3 rpm安装"></a>1.3 rpm安装</h2><p>Ubuntu的软件包格式是deb，如果要安装rpm的包，则要先用alien把rpm转换成deb。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install alien <span class="comment">#alien默认没有安装，所以首先要安装它</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo alien xxxx.rpm <span class="comment">#将rpm转换位deb，完成后会生成一个同名的xxxx.deb</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i xxxx.deb <span class="comment">#安装</span></span><br></pre></td></tr></table></figure><p>注意，用alien转换的deb包并不能保证100%顺利安装，所以可以找到deb最好直接用deb</p><p><strong>方法一：</strong></p><ol><li>先安装 alien 和 fakeroot 这两个工具，其中前者可以将 rpm 包转换为 deb 包。安装命令为：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install alien fakeroot</span><br></pre></td></tr></table></figure><ol start="2"><li><p>将需要安装的 rpm 包下载备用，假设为 package.rpm。</p></li><li><p>使用 alien 将 rpm 包转换为 deb 包：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fakeroot alien package.rpm</span><br></pre></td></tr></table></figure><ol start="4"><li>一旦转换成功，我们可以即刻使用以下指令来安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i package.deb</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rpm alien</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien -d package.rpm</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i package.deb</span><br></pre></td></tr></table></figure><h2 id="1-4-卸载"><a href="#1-4-卸载" class="headerlink" title="1.4 卸载"></a>1.4 卸载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge xxx           <span class="comment"># 卸载1</span></span><br><span class="line">sudo apt-get remove --purge xxx  <span class="comment"># 卸载2</span></span><br><span class="line">sudo apt-get autoremove xxx      <span class="comment"># 卸载3</span></span><br></pre></td></tr></table></figure><h1 id="2-环境类软件"><a href="#2-环境类软件" class="headerlink" title="2.环境类软件"></a>2.环境类软件</h1><h2 id="2-1-jdk"><a href="#2-1-jdk" class="headerlink" title="2.1 jdk"></a>2.1 jdk</h2><blockquote><p>我下载的时候版本下载错了,导致配置完环境提示无法解析二进制码,我错下成了arm64位的版本,应该下载的是<strong>x64</strong>版本</p></blockquote><p>放到自己能找到的目录,然后按照如下编辑配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line">sudo gedit /etc/profile</span><br><span class="line"><span class="comment">#在最下面进行添加如下配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#jdk安装路径</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/envir/java/jdk1.8.0_271 <span class="comment">#这里的地址写自己的实际地址,你的和我的可能不一样</span></span><br><span class="line"><span class="comment">#jre安装路径</span></span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/usr/<span class="built_in">local</span>/envir/java/jdk1.8.0_271/jre <span class="comment">#这里的地址写自己的实际地址,你的和我的可能不一样</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后回到命令行,让环境生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#让环境生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment">#测试是否配置成功,看是否会出现正确的java版本信息</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h2 id="2-2-tomcat"><a href="#2-2-tomcat" class="headerlink" title="2.2 tomcat"></a>2.2 tomcat</h2><p>先在下载的文件夹进行解压,然后移动到需要放的位置,要不然权限不够还需要修改权限,放好后直接进入bin目录,用命令<code>./startup.sh</code>启动服务,然后用网页访问<code>http://localhost:8080/</code>看服务是否启动.</p><h2 id="2-3-maven"><a href="#2-3-maven" class="headerlink" title="2.3 maven"></a>2.3 maven</h2><p>下载解压后放到你能找到的位置,然后记住当前地址,到配置文件中更改地址方便全局访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line">sudo gedit /etc/profile</span><br><span class="line"><span class="comment">#在最下面进行添加如下配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#maven安装路径</span></span><br><span class="line">MAVEN_HOME=/usr/<span class="built_in">local</span>/envir/apache-maven-3.6.3 <span class="comment">#写自己的地址</span></span><br><span class="line"><span class="built_in">export</span> MAVEN_HOME</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin</span><br></pre></td></tr></table></figure><p>然后回到命令行,让环境生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#让环境生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment">#测试是否配置成功,看是否会出现正确的版本信息</span></span><br><span class="line">mvn -v</span><br></pre></td></tr></table></figure><p>修改maven的常用配置:</p><ol><li><p>创建reop目录,方便后期下载的依赖进行查找</p></li><li><p>修改setting文件,配置依赖的存放地址和修改使用阿里云的源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--在conf的settings.xml文件中进行添加本地依赖库和在mirros标签中添加阿里云--&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--本地依赖库地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    /usr/local/envir/apache-maven-3.6.3/repo</span><br><span class="line"><span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--mirrors标签中配置阿里云源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>AliMaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>记得修改idea中的maven配置</p></li></ol><h2 id="2-4mysql"><a href="#2-4mysql" class="headerlink" title="2.4mysql"></a>2.4mysql</h2><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure></li><li><p>启动关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br><span class="line">service mysql stop</span><br></pre></td></tr></table></figure></li><li><p>判断是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure></li><li><p>进入mysql shell界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>由于新版本没有在安装的时候提示输入用户名和密码，这里会提示错误，也有的人可以正常登录，不能登录的可以按照下面方法修改密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-1.打开文件复制用户名和密码</span><br><span class="line">sudo gedit /etc/mysql/debian.cnf</span><br><span class="line">-2.用刚刚复制的用户名和密码重新进入mysql shell</span><br><span class="line">mysql -u debian-sys-maint -p</span><br><span class="line">-3.修改密码</span><br><span class="line">show databases;</span><br><span class="line">use mysql;</span><br><span class="line">-下面的123456是我设置的密码，你可以输入别的</span><br><span class="line">update user <span class="built_in">set</span> authentication_string=123456 <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">update user <span class="built_in">set</span> plugin=<span class="string">&quot;mysql_native_password&quot;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="built_in">exit</span>;</span><br><span class="line">-4.重启登录</span><br><span class="line">mysql restart；</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>彻底卸载mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">首先在终端中查看 MySQL 的依赖项：</span><br><span class="line">dpkg --list|grep mysql</span><br><span class="line"></span><br><span class="line">卸载： </span><br><span class="line">sudo apt-get remove mysql-common</span><br><span class="line"></span><br><span class="line">卸载：</span><br><span class="line">sudo apt-get autoremove --purge mysql-server-5.7</span><br><span class="line"></span><br><span class="line">清除残留数据：</span><br><span class="line">dpkg -l|grep ^rc|awk <span class="string">&#x27;&#123;print$2&#125;&#x27;</span>|sudo xargs dpkg -P</span><br><span class="line"></span><br><span class="line">再次查看 MySQL 的剩余依赖项：</span><br><span class="line">dpkg --list|grep mysql</span><br><span class="line"></span><br><span class="line">继续删除剩余依赖项，如：</span><br><span class="line">sudo apt-get autoremove --purge mysql-apt-config</span><br><span class="line"></span><br><span class="line">至此已经没有了 MySQL 的依赖项，彻底删除，Good Luck</span><br></pre></td></tr></table></figure></li></ol><h1 id="3-工作类类软件"><a href="#3-工作类类软件" class="headerlink" title="3.工作类类软件"></a>3.工作类类软件</h1><blockquote><p>自己找官方连接下载</p></blockquote><h2 id="idea-办公"><a href="#idea-办公" class="headerlink" title="idea_办公"></a>idea_办公</h2><h2 id="datadrap-数据库"><a href="#datadrap-数据库" class="headerlink" title="datadrap_数据库"></a>datadrap_数据库</h2><h2 id="postman-接口测试"><a href="#postman-接口测试" class="headerlink" title="postman_接口测试"></a>postman_接口测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install postman</span><br></pre></td></tr></table></figure><h2 id="terminal终端工具-可同时开多个窗口"><a href="#terminal终端工具-可同时开多个窗口" class="headerlink" title="terminal终端工具_可同时开多个窗口"></a>terminal终端工具_可同时开多个窗口</h2><h2 id="virtualbox虚拟机"><a href="#virtualbox虚拟机" class="headerlink" title="virtualbox虚拟机"></a>virtualbox虚拟机</h2><p><a href="https://blog.csdn.net/a805607966/article/details/105877055">参考地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装包在官网自行下载，然后按照下面的步骤进行安装即可。实现的功能如下：</span><br><span class="line">1.软件安装</span><br><span class="line">2.屏幕大小调节</span><br><span class="line">3.文件夹共享</span><br><span class="line">4.usb共享</span><br></pre></td></tr></table></figure><h2 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h2><h2 id="finalshell"><a href="#finalshell" class="headerlink" title="finalshell"></a>finalshell</h2><h1 id="4-效率类软件"><a href="#4-效率类软件" class="headerlink" title="4.效率类软件"></a>4.效率类软件</h1><blockquote><p>自己找官方连接下载</p></blockquote><h2 id="flameshot-截图工具"><a href="#flameshot-截图工具" class="headerlink" title="flameshot_截图工具"></a>flameshot_截图工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置截图快捷键</span></span><br><span class="line">1. 打开系统的设置,找到键盘快捷键,翻到最下面点击`+`号进行添加</span><br><span class="line">2. 名字随意,命令`flameshot gui`</span><br><span class="line">3. 快捷键自己设置,我用`f1`</span><br></pre></td></tr></table></figure><h2 id="图片查看软件-GIMP"><a href="#图片查看软件-GIMP" class="headerlink" title="图片查看软件-GIMP"></a>图片查看软件-GIMP</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:otto-kesselgulasch/gimp</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gimp</span><br></pre></td></tr></table></figure><h2 id="翻译软件"><a href="#翻译软件" class="headerlink" title="翻译软件"></a>翻译软件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install goldendict</span><br><span class="line">安装完成后，打开软件选择 编辑-&gt; 词典 菜单，打开 词典来源--网站，去掉下面两张图中所有默认打钩的地方， youdao 这一栏。</span><br><span class="line"></span><br><span class="line">地址如下：</span><br><span class="line">http://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8</span><br></pre></td></tr></table></figure><h2 id="视频播放器–smplayer"><a href="#视频播放器–smplayer" class="headerlink" title="视频播放器–smplayer"></a>视频播放器–smplayer</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> sudo apt-get install smplayer</span><br></pre></td></tr></table></figure><h2 id="文本编辑器–notepad-替代品notepadqq"><a href="#文本编辑器–notepad-替代品notepadqq" class="headerlink" title="文本编辑器–notepad++替代品notepadqq"></a>文本编辑器–notepad++替代品notepadqq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:notepadqq-team/notepadqq</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install notepadqq</span><br></pre></td></tr></table></figure><h2 id="思维导图–xmind"><a href="#思维导图–xmind" class="headerlink" title="思维导图–xmind"></a>思维导图–xmind</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">打开官网下载页，点击 Download For Linux 按钮，下载安装文件，将安装文件移动到常用软件安装目录</span><br><span class="line"></span><br><span class="line">右击安装文件，点击 提取到此处 选项，归档管理器会在当前目录新建一个同名文件夹并将文件解压到该文件夹下</span><br><span class="line"></span><br><span class="line">打开命令行，进入文件夹，安装软件依赖项，执行如下命令：</span><br><span class="line"></span><br><span class="line">  sudo sh ./setup.sh</span><br><span class="line"></span><br><span class="line">  XMind依赖于Java8，因此安装完成后需要安装JDK，并在XMind配置文件里面进行配置。</span><br><span class="line"></span><br><span class="line">安装JDK，执行如下命令：</span><br><span class="line"></span><br><span class="line">  sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line">用文本编辑器打开XMind文件夹下64位文件的配置文件</span><br><span class="line"></span><br><span class="line">  sudo <span class="built_in">cd</span> xmind-8-update8-linux/XMind_amd64/</span><br><span class="line"></span><br><span class="line">  sudo gedit ./XMind.ini</span><br><span class="line"></span><br><span class="line">在XMind.ini文件中添加以下内容</span><br><span class="line"></span><br><span class="line">  -eclipse.keyring</span><br><span class="line"></span><br><span class="line">  @user.home/.xmind/secure_storage_linux</span><br><span class="line"></span><br><span class="line">  -vm</span><br><span class="line"></span><br><span class="line">  /usr/lib/jvm/java-8-openjdk-amd64/bin</span><br><span class="line"></span><br><span class="line">  -vmargs</span><br><span class="line"></span><br><span class="line">  -Dfile.encoding=UTF-8</span><br><span class="line"></span><br><span class="line">  安装完成后，打开XMind安装文件夹，双击XMind_amd64文件夹下XMind文件即可打开XMind。为了打开方便打开，我们给XMind新建一个桌面快捷方式。</span><br><span class="line"></span><br><span class="line">新建一个桌面快捷方式</span><br><span class="line"></span><br><span class="line">  $ <span class="built_in">cd</span> 桌面</span><br><span class="line"></span><br><span class="line">  $ touch XMind.desktop</span><br><span class="line"></span><br><span class="line">修改桌面快捷方式可执行权限</span><br><span class="line"></span><br><span class="line">  $ sudo chmod a+x XMind.desktop</span><br><span class="line"></span><br><span class="line">用文本编辑器打开桌面快捷方式</span><br><span class="line"></span><br><span class="line">  $ gedit XMind.desktop</span><br><span class="line"></span><br><span class="line">在桌面快捷方式中添加以下内容</span><br><span class="line"></span><br><span class="line">  Name=XMind</span><br><span class="line"></span><br><span class="line">  Comment=XMind</span><br><span class="line"></span><br><span class="line">  Exec=/home/dcg/文档/xmind-8-update8-linux/XMind_amd64/./XMind</span><br><span class="line"></span><br><span class="line">  Icon=/home/dcg/文档/xmind-8-update8-linux/XMind.png</span><br><span class="line"></span><br><span class="line">  Path=/home/dcg/文档/xmind-8-update8-linux/XMind_amd64/</span><br><span class="line"></span><br><span class="line">  Terminal=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  Type=Application</span><br><span class="line"></span><br><span class="line">  StartupNotify=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  注意， /home/dcg/文档/xmind-8-update8-linux/ 是我的XMind安装目录； XMind.png 是我下载的XMind图标文件，请大家根据自己的安装目录和文件地址进行修改。</span><br><span class="line"></span><br><span class="line">  至此XMind已经安装完成了，点击XMind桌面快捷方式即可打开XMind使用了。</span><br></pre></td></tr></table></figure><h2 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h2><h2 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h2><h2 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h2><h2 id="copyq-剪贴板管理工具"><a href="#copyq-剪贴板管理工具" class="headerlink" title="copyq_剪贴板管理工具"></a>copyq_剪贴板管理工具</h2>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 在`首选项`中设置,</span><br><span class="line">2. `显示或隐藏主窗口`,我用的 `Ctrl+` ,这和我win中的快捷键一样</span><br><span class="line"></span><br><span class="line">或者直接在软件的快捷键设置中也可以设置,不用上面这么麻烦.</span><br></pre></td></tr></table></figure><h2 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h2><p> <a href="https://pinyin.sogou.com/linux/">官方链接</a> <a href="https://pinyin.sogou.com/linux/help.php">安装教程</a></p><p><strong>idea中输入法光标不跟随问题解决</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是因为默认jdk版本和输入法的不知道什么东西冲突引起的，网上的教程</span><br><span class="line">1. idea先安装JetBrains Runtime 插件</span><br><span class="line">2. 下载jbr文件，网址是https://download.csdn.net/download/qq_41859728/12984384</span><br><span class="line">3. ctrl+shfit+a 输入choose runtime，选择jbr文件路径安装即可</span><br></pre></td></tr></table></figure><h2 id="快速启动工具——类似于everything"><a href="#快速启动工具——类似于everything" class="headerlink" title="快速启动工具——类似于everything"></a>快速启动工具——类似于everything</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fsearch 自己搜索安装，</span></span><br><span class="line"><span class="comment">#更推荐Albert，但我的依赖报错无法使用</span></span><br></pre></td></tr></table></figure><h2 id="picgo图床工具"><a href="#picgo图床工具" class="headerlink" title="picgo图床工具"></a>picgo图床工具</h2><p> <a href="">官网链接</a></p><p>  因为想配合typora使用，所以最后安装的命令行版本，typora设置图片自动上传图床功能：</p><p>  进入文件-设置-偏好设置-图像<img src="https://i.loli.net/2021/01/03/chgJTIZudFEK1m5.png" alt="image-20210103000017152"></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优先完成图中的123设置，然后打开配置，修改配置文件为如下即可(注意：下面的是我个人的smms地址和GitHub地址，我的token没写，要用相同图床的自己去注册吧~~如果是我自己忘了，请去查看为知笔记中的备份文件.)</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;current&quot;</span>: <span class="string">&quot;smms&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uploader&quot;</span>: <span class="string">&quot;smms&quot;</span>,</span><br><span class="line">    <span class="string">&quot;smms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;token&quot;</span>: <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;list&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;SM.MS图床&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;smms&quot;</span>,</span><br><span class="line">        <span class="string">&quot;visible&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;GitHub图床&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;github&quot;</span>,</span><br><span class="line">        <span class="string">&quot;visible&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;github&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;branch&quot;</span>: <span class="string">&quot;master&quot;</span>,</span><br><span class="line">      <span class="string">&quot;customUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;repo&quot;</span>: <span class="string">&quot;fendaabc/for-picgo&quot;</span>,</span><br><span class="line">      <span class="string">&quot;token&quot;</span>: <span class="string">&quot;   &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;shortKey&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;picgo:upload&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;CommandOrControl+Shift+P&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;upload&quot;</span>,</span><br><span class="line">        <span class="string">&quot;label&quot;</span>: <span class="string">&quot;快捷上传&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;server&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;port&quot;</span>: 36677,</span><br><span class="line">      <span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;enable&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;showUpdateTip&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;picgoPlugins&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;debug&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;PICGO_ENV&quot;</span>: <span class="string">&quot;GUI&quot;</span>,</span><br><span class="line">  <span class="string">&quot;needReload&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后点击验证是否可以正常上传，这些配置文件都是我在win平台原来配置好的提取出来的，应该是没啥问题，提示上传成功的话就可以正常使用了。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">## 微信/钉钉（使用的wine方法安装）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法1：（我的没成功，用的公司内网的方法二）</span></span><br><span class="line">  <span class="comment">#先装上wine</span></span><br><span class="line">  <span class="comment">#到一个你知道的目录</span></span><br><span class="line">  <span class="built_in">cd</span> ~/soft</span><br><span class="line">  <span class="comment">#如果没git的话就装一下，有就算了</span></span><br><span class="line">  sudo apt install git</span><br><span class="line">  <span class="comment">#拉取wine代码</span></span><br><span class="line">  git <span class="built_in">clone</span> https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git</span><br><span class="line">  <span class="comment">#执行wine安装</span></span><br><span class="line">  wget -O- https://deepin-wine.i-m.dev/setup.sh | sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法2： 先安装docker，然后安装的wine和微信，这个方法成功了但不在公司内网的可能没法用，具体使用我后期再研究一下</span></span><br><span class="line"><span class="comment">#docker</span></span><br><span class="line"><span class="comment">#如果之前安装过docker,请删掉</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br><span class="line"><span class="comment">#首先安装依赖:</span></span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common</span><br><span class="line"><span class="comment">#添加信任 Docker 的 GPG 公钥:</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment">#对于 amd64 架构的计算机，添加软件仓库:</span></span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br><span class="line"><span class="comment">#安装docker</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment">#添加普通（sudo管理权限）用户到 dokcer组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># USER 为当前你的用户名变量 将$USER改成自己的用户名</span></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"><span class="comment">#验证docker环境（重启或注销）</span></span><br><span class="line">sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行以下命令验证</span></span><br><span class="line">docker ps </span><br><span class="line">wechat</span><br><span class="line"><span class="comment"># install wechat-commandline</span></span><br><span class="line">bash &lt;(curl -L -s http://192.168.1.51/shell/wechat.sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装微信并启动 check wechat-commandline</span></span><br><span class="line"><span class="built_in">which</span> wechat</span><br><span class="line"><span class="comment"># wechat help</span></span><br><span class="line">wechat -h</span><br><span class="line"><span class="comment"># install wechat app</span></span><br><span class="line">wechat -i</span><br><span class="line"><span class="comment"># start wechat app</span></span><br><span class="line">wechat --start</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装钉钉</span></span><br><span class="line"><span class="comment">#(推荐使用在线安装，成功率更高，但我这里使用的离线的也成功了，文件下载地址：(https://github.com/nashaofu/dingtalk/releases/tag/v2.1.9))</span></span><br><span class="line"><span class="comment">#方法一离线：</span></span><br><span class="line">sudo dpkg -i 文件名</span><br><span class="line"><span class="comment">#方法二在线：</span></span><br><span class="line">sudo apt-get install com.dingtalk.deepin</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装微信</span></span><br><span class="line">sudo apt-get install com.qq.weixin.deepin</span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装qq</span></span><br><span class="line">sudo apt-get install com.qq.weixin.deepin</span><br></pre></td></tr></table></figure><ul><li><h2 id="系统性能监控软件"><a href="#系统性能监控软件" class="headerlink" title="系统性能监控软件"></a>系统性能监控软件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y indicator-sysmonitor</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装好后，搜索sys然后打开，设置首选项，设置开机自启动，然后我默认设置的显示cpu-内存和网速</span></span><br><span class="line">CPU:&#123;cpu&#125; | 内存:&#123;mem&#125; | 网速:&#123;net&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-终端调教"><a href="#5-终端调教" class="headerlink" title="5.终端调教"></a>5.终端调教</h1><ol><li><p>git—- <code>sudo apt-get install git</code></p></li><li><p>ssh— <code>sudo apt-get install ssh</code></p></li><li><p>历史命令匹配和忽略大小写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">sudo gedit ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#要添加的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#历史命令前缀匹配</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\e[A&quot;: history-search-backward&#x27;</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\e[B&quot;: history-search-forward&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略命令大小写匹配：在~/.inputrc文件加入以下两行</span></span><br><span class="line"><span class="built_in">set</span> completion-ignore-case on</span><br><span class="line"><span class="built_in">set</span> show-all-if-ambiguous on</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#让命令生效</span></span><br><span class="line"><span class="built_in">source</span> ～/.bashrc </span><br></pre></td></tr></table></figure></li><li><p>ubuntu如何设置软件的开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bash中输入如下内容，然后在打开的页面中选中需要自启动的文件（appimages或者.sh）</span></span><br><span class="line">gnome-session-properties </span><br></pre></td></tr></table></figure></li><li><p>配置git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#1. 先用给定连接和公司邮箱注册gitlab( 我的连接:http://192.168.1.35/profile)</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">#2.安装git</span></span><br><span class="line">   sudo apt-get install git</span><br><span class="line">   配置环境</span><br><span class="line">   </span><br><span class="line">   <span class="comment">#3. 配置环境</span></span><br><span class="line">   git config --global user.name <span class="string">&quot;yangbin&quot;</span> <span class="comment">#这里写自己的名字</span></span><br><span class="line">   git config --global user.email <span class="string">&quot;yangbin@swifthealth.cn&quot;</span> <span class="comment">#这里写自己的公司邮箱</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">#4.生成SSH密钥，输入下面命令后直接回车</span></span><br><span class="line">ssh-keygen -C <span class="string">&quot;你的注册邮箱&quot;</span> -t rsa</span><br><span class="line">       </span><br><span class="line">   <span class="comment">#5. 然后从图中能看到你的key保存的位置,用gedit命令访问那个位置</span></span><br><span class="line">   <span class="comment">#下面是我的key的访问,打开后复制出来</span></span><br><span class="line">   gedit /home/yb/.ssh/id_rsa.pub</span><br><span class="line">      </span><br><span class="line">   <span class="comment">#6. 回到网页版的gitlab,左边点击`SSH Keys`,然后在右侧添加刚才复制的key,title随意.</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">#7. 回到命令行,将key加入到ssh-agent中</span></span><br><span class="line">   ssh-add ~/.ssh/id_rsa</span><br><span class="line">        </span><br><span class="line">   <span class="comment">#8. 然后如果需要使用的话,可以在本地自己希望使用的位置创建一个文件夹,再进入文件夹并进行git目录的初始化(命令一行一行执行)</span></span><br><span class="line">   <span class="built_in">cd</span>  ~/文档/</span><br><span class="line">   mkdir work</span><br><span class="line">   <span class="built_in">cd</span> work</span><br><span class="line">   git init</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>wine中微信安装完无法输入中文，只能输入英文</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在搜狗输入法的图标上右键单击，然后点重新启动，重新加载输入法就好了。。。。。。忘了什么原因了，反正这样处理了好几次了，目前没有根治这个问题</span></span><br></pre></td></tr></table></figure></li></ol>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#先考虑上面的方法吧，不行再用这个~~~</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">#打开run.sh文件，然后添加后面的几个export，不建议给777的权限</span></span><br><span class="line">   <span class="built_in">cd</span> /opt/deepinwine/tools/</span><br><span class="line">   sudo chmod 777 run.sh</span><br><span class="line">sudo gedit run.sh</span><br><span class="line">   </span><br><span class="line">   <span class="comment">#需要将如下内容进行添加并保存</span></span><br><span class="line">   <span class="built_in">export</span> GTK_IM_MODULE=<span class="string">&quot;fcitx&quot;</span></span><br><span class="line">   <span class="built_in">export</span> QT_IM_MODULE=<span class="string">&quot;fcitx&quot;</span> </span><br><span class="line">   <span class="built_in">export</span> XMODIFIERS=<span class="string">&quot;@im=fcitx&quot;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure><h1 id="6-其他软件"><a href="#6-其他软件" class="headerlink" title="6.其他软件"></a>6.其他软件</h1><blockquote><p>自己找官方连接下载</p></blockquote><h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2><p><a href="https://music.163.com/#/download">官网链接</a></p><h2 id="VLC"><a href="#VLC" class="headerlink" title="VLC"></a>VLC</h2><p>(自带应用商店)</p><h2 id="xmind"><a href="#xmind" class="headerlink" title="xmind"></a>xmind</h2><p><a href="https://www.xmind.cn/download/">官网链接</a></p><h2 id="clashy-appimage格式"><a href="#clashy-appimage格式" class="headerlink" title="clashy_appimage格式"></a>clashy_appimage格式</h2><h2 id="appimagelauncher"><a href="#appimagelauncher" class="headerlink" title="appimagelauncher"></a>appimagelauncher</h2><p><a href="https://blog.csdn.net/u012057432/article/details/103097632">参考文章</a> <a href="https://github.com/TheAssassin/AppImageLauncher/releases">下载地址</a></p><h2 id="gimp图片处理软件"><a href="#gimp图片处理软件" class="headerlink" title="gimp图片处理软件_"></a>gimp图片处理软件_</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install gimp</span><br></pre></td></tr></table></figure><h2 id="Albert-快速启动工具官方地址"><a href="#Albert-快速启动工具官方地址" class="headerlink" title="Albert_快速启动工具官方地址"></a>Albert_快速启动工具<a href="https://software.opensuse.org/download.html?project=home:manuelschneid3r&package=albert">官方地址</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下载的软件，链接装不上</span><br></pre></td></tr></table></figure><ul><li></li></ul><p>没测试的方法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">由于不太放心，所以我还是安装了wine，和方法一的第一步一样，</span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">sudo apt install git（我没有安装过git，所以需要提前安装）</span><br><span class="line">git clone http<span class="variable">s:</span>//gitee.<span class="keyword">com</span>/wszqkzqk/deepin-wine-<span class="keyword">for</span>-ubuntu.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行</span><br><span class="line"></span><br><span class="line">wget -O- http<span class="variable">s:</span>//deepin-wine.i-<span class="keyword">m</span>.dev/setup.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br><span class="line"></span><br><span class="line">安装qq</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="built_in">get</span> install <span class="keyword">com</span>.qq.weixin.deepin</span><br><span class="line"></span><br><span class="line">安装微信</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="built_in">get</span> install <span class="keyword">com</span>.qq.weixin.deepin</span><br><span class="line"></span><br><span class="line">同理，根据提示安装钉钉 sudo apt-<span class="built_in">get</span> install <span class="keyword">com</span>.dingtalk.deepin</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Wine"><a href="#Wine" class="headerlink" title="Wine"></a>Wine</h2><p><a href="https://wiki.winehq.org/Ubuntu">参考地址1</a></p><p><a href="">参考地址2</a></p><p><a href="https://www.cnblogs.com/sbrk/p/wine.html">参考地址3</a></p><p><a href="https://www.cnblogs.com/chenzhen0530/p/13885273.html">https://www.cnblogs.com/chenzhen0530/p/13885273.html</a></p><p><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu">https://github.com/wszqkzqk/deepin-wine-ubuntu</a></p><p><a href="https://blog.csdn.net/qq_32115939/article/details/109196077">https://blog.csdn.net/qq_32115939/article/details/109196077</a></p><h2 id="有道词典"><a href="#有道词典" class="headerlink" title="有道词典"></a>有道词典</h2><p>下载<a href="http://cidian.youdao.com/multi.html">地址：</a></p><p>安装前先更新系统依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt-get -f -y install  </span><br></pre></td></tr></table></figure><h1 id="7-其他问题"><a href="#7-其他问题" class="headerlink" title="7.其他问题"></a>7.其他问题</h1><ol><li><p>idea窗口在执行搜索的时候卡住不动：</p><p>强行关闭图形化界面的方法，终端执行命令：xkill，然后用鼠标点击需要关闭的窗口。</p></li><li><p>台式机耳机插入没声音：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.打开终端</span><br><span class="line">2.执行‘alsamixer’，会弹出一个窗口下面分别写着master headphone，然后用tab键切换到headphone上面，按上下键调整音量大小，提高到白色或者红色</span><br><span class="line">3.尽量是拔掉耳机操作，我插着耳机操作完没反应，拔掉重新弄了才有反应，</span><br><span class="line">4.调整完之后esc退出，插上耳机，电脑右上角调整音量试一下</span><br></pre></td></tr></table></figure></li><li><p>ubuntu页面右上角电源位置的设置按钮消失，软件中的setting也没了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt  install gnome-control-center</span><br></pre></td></tr></table></figure></li><li><p>搜狗输入法每次重启皮肤透明的解决办法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br><span class="line"><span class="comment">#搜狗输入法每次重启皮肤透明的解决办法</span></span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> XMODIFIERS=<span class="string">&quot;@im=fcitx&quot;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>安装dbeaver连接数据库的时候提示驱动无法安装，解决办法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开“窗口”-&gt;“首选项”-&gt;“驱动”-&gt;&quot;Maven&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#点击“添加”阿里云中央仓库地址：</span></span><br><span class="line">http://maven.aliyun.com/nexus/content/groups/public/</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者可以使用idea在pom文件中将这里需要下载的驱动版本下载好，然后在dbeaver中选中刚刚下载的pom的文件夹也可</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/xZ8iKEF1TVshOaL.png" alt="image-20210220145631684"></p></li><li><p>查看ubuntu系统的内存占用，用窗口杀死线程，查看文件系统占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#alt+f2打开命令行输入，</span></span><br><span class="line"><span class="comment">#输入命令进行查看</span></span><br><span class="line">gnome-system-monitor</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#或者查找进程用命令行杀死</span></span><br><span class="line">ps -ef | grep redis  <span class="comment">#以redis为例，查到id是29028</span></span><br><span class="line"><span class="built_in">kill</span> -9 29028</span><br></pre></td></tr></table></figure></li><li><p>查看linux端口是否被占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat  -anp  |grep   端口号</span><br><span class="line"><span class="comment">#如果需要接触占用直接用上面的命令kill掉</span></span><br></pre></td></tr></table></figure></li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toots 2020 Dec.14 - Dec.20</title>
      <link href="2020/12/14/Toots-2020-Dec.14-Dec.20/"/>
      <url>2020/12/14/Toots-2020-Dec.14-Dec.20/</url>
      
        <content type="html"><![CDATA[<h1 id="Dec-14"><a href="#Dec-14" class="headerlink" title="Dec.14"></a><strong>Dec.14</strong></h1><hr><p>- </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用算法</title>
      <link href="2020/12/12/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>2020/12/12/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><img src="C:\Users\MSI-NB\AppData\Roaming\Typora\typora-user-images\image-20201212032444139.png" alt="冒泡排序图解"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构相关知识补充</title>
      <link href="2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
      <url>2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote><p>先进后出     压栈pop  弹栈push</p></blockquote><h4 id="应用"><a href="#应用" class="headerlink" title="应用:"></a>应用:</h4><ol><li>方法的调用,method1()在main()上面,method1方法没有执行完,main方法无法结束</li><li>手枪弹匣,先进去的最后发射出来</li></ol><hr><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote><p>先进先出</p></blockquote><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用:"></a>应用:</h4><ol><li>吃饭排队</li><li>高铁各车厢进隧道出隧道的顺序</li></ol><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote><p>查询快,增删慢</p></blockquote><p>增删慢:</p><ol><li> 数组长度不可变</li><li>每次增删需要创建新数组,并将需要的内容复制到新数组中,删除原来的引用,再赋值给原值,后创建复制和删除三步操作耗时高</li></ol><p>查询快: </p><ol><li>有索引   </li><li>数组元素内存空间连续分配</li></ol><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用:"></a>应用:</h4><ol><li>java.util.ArrayList</li></ol><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote><p>查询慢,增删快</p></blockquote><ol><li><p>单向链表 –&gt; 只能从前往后找</p></li><li><p>双向链表  –&gt;  可以从前往后找,也可以从后往前找</p><ol><li><h4 id="应用-java-util-LinkedList集合"><a href="#应用-java-util-LinkedList集合" class="headerlink" title="应用: java.util.LinkedList集合"></a>应用: java.util.LinkedList集合</h4></li></ol></li></ol><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><blockquote><p>查询特别快,增删相对也快</p></blockquote><p><img src="C:\Users\MSI-NB\AppData\Roaming\Typora\typora-user-images\image-20201212033220745.png" alt="二叉树&amp;红黑树&amp;平衡树&amp;不平航树结构"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合的相关知识补充</title>
      <link href="2020/12/12/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
      <url>2020/12/12/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h1 id="集合综合对比图"><a href="#集合综合对比图" class="headerlink" title="集合综合对比图"></a>集合综合对比图</h1><p><img src="C:\Users\MSI-NB\AppData\Roaming\Typora\typora-user-images\image-20201212035806458.png" alt="集合对比图"></p><h1 id="Colletion"><a href="#Colletion" class="headerlink" title="Colletion"></a>Colletion</h1><p><img src="C:\Users\MSI-NB\AppData\Roaming\Typora\typora-user-images\image-20201212034055240.png" alt="集合的继承体系"></p><h2 id="java-util-List"><a href="#java-util-List" class="headerlink" title="java.util.List"></a>java.util.List</h2><blockquote><p>有序、有索引、可重复</p></blockquote><h3 id="java-util-ArrayList"><a href="#java-util-ArrayList" class="headerlink" title="java.util.ArrayList"></a>java.util.ArrayList</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>创建一个空的ArrayList集合,初始容量是<strong>0</strong>,第一次扩容后容量变为<strong>10</strong>,当添加到第11个元素的时候,后面扩容为原有容量的<strong>1.5倍</strong>,因为每次增加内容都需要进行再次扩容,进行元素的复制和删除操作,占用资源较多,所以尽量避免空参构造,尽量创建数组的时候<strong>指定好大小</strong>,避免多次扩容浪费资源.<a href="%E5%8F%82%E7%9C%8B%E8%A7%86%E9%A2%91:29_ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86.avi">^1</a></p><hr><h3 id="java-util-LinkedList"><a href="#java-util-LinkedList" class="headerlink" title="java.util.LinkedList"></a>java.util.LinkedList</h3><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>查找的时候:(使用<strong>简单二分查找法</strong>)<a href="%E5%8F%82%E7%9C%8B%E8%A7%86%E9%A2%91:32_LinkedList%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95add.avi">^2</a></p><ol><li>如果索引值&lt;长度的一半,从 <strong>头节点</strong>开始找</li><li>如果索引值&gt;长度的一半,从 <strong>尾节点</strong>开始找</li></ol><hr><h2 id="java-util-Set"><a href="#java-util-Set" class="headerlink" title="java.util.Set"></a>java.util.Set</h2><blockquote><p>无索引、不可重复</p></blockquote><h3 id="java-util-HashSet"><a href="#java-util-HashSet" class="headerlink" title="java.util.HashSet"></a>java.util.HashSet</h3><blockquote><p>此类实际上<strong>是</strong>一个<strong>HashMap实例</strong></p></blockquote><p>特点:</p><ol><li><p><strong>底层</strong>数据结构: <strong>哈希表</strong>: 数组 + 单向链表/红黑树(单向链表节点数&gt;8)</p></li><li><p><strong>查询</strong>速度嗷嗷<strong>快</strong>,<strong>增删</strong>也<strong>快</strong></p></li><li><p>无索引</p></li><li><p>不可重复</p></li><li><p><strong>无序</strong>: 不保证存入和取出顺序一致</p></li></ol><hr><h3 id="java-util-LinkedHashSet"><a href="#java-util-LinkedHashSet" class="headerlink" title="java.util.LinkedHashSet"></a>java.util.LinkedHashSet</h3><p>特点:</p><ol><li><strong>底层</strong>数据结构: <strong>哈希表</strong>: 数组 + 单向链表 –&gt; 数组 + 双向链表</li><li><strong>查询</strong>速度嗷嗷<strong>快</strong>,<strong>增删</strong>也<strong>快</strong> (没hashset快)</li><li>无索引</li><li>不可重复</li><li><strong>有序</strong>:  存入和取出顺序一致</li></ol><hr><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="java-util-HashMap-lt-K-V-gt"><a href="#java-util-HashMap-lt-K-V-gt" class="headerlink" title="java.util.HashMap&lt;K,V&gt;"></a>java.util.HashMap&lt;K,V&gt;</h3><blockquote><p>​       <strong>初始容量16,加载因子0.75,扩容为2倍</strong></p></blockquote><p>特点:</p><ol><li>键唯一,值可重复</li><li>键: 具备哈希特性,采用哈希表结构(数组+单向链表)</li><li>哈希表结构(数组+单向链表): <strong>无索引,元素不可重复,无序</strong></li><li>HashMap集合的键所属类<strong>必须覆盖重写hashCode和equals方法</strong></li><li>可以存储null键和null值</li><li>线程不同步,线程不安全,效率高</li></ol><hr><h3 id="java-util-LinkedHashMap-lt-K-V-gt"><a href="#java-util-LinkedHashMap-lt-K-V-gt" class="headerlink" title="java.util.LinkedHashMap&lt;K,V&gt;"></a>java.util.LinkedHashMap&lt;K,V&gt;</h3><p>特点:</p><ol><li>键唯一,值可重复</li><li>键: 具备哈希特性+链表结构,采用<strong>哈希表结构+链表结构</strong>(数组+双向链表),</li><li>哈希表结构+单项链表(数组+双向链表): <strong>无索引,元素不可重复,有序</strong></li><li>集合的键的所属类<strong>必须覆盖重写hashCode和equals方法</strong></li><li>可以存储null键和null值</li><li>线程不同步,线程不安全,效率高</li></ol><hr><h3 id="java-util-HashTable-lt-K-V-gt"><a href="#java-util-HashTable-lt-K-V-gt" class="headerlink" title="java.util.HashTable&lt;K,V&gt;"></a>java.util.HashTable&lt;K,V&gt;</h3><p>特点(hashTable VS hashMap):</p><ol><li>底层数据结构都是 <strong>哈希表结构</strong>(数组+单向链表)</li><li>HashMap允许存储null键和null值,HashTable不允许</li><li>HashMap线程不同步,效率高;HashTable<strong>线程同步</strong>,效率低</li></ol><p>注意:</p><ol><li>Properties集合是Map接口的实现类,Map接口中定义的方法,Properties集合都可以用</li><li>HashTable类是Map接口的实现类,也定义了泛型K :键的类型,V: 值的类型</li><li>但是Properties集合 继承HashTable类时,已经确定键的类型: Object,值的类型: Object,所以创建Properties集合对象时,不能再指定键和值的类型</li><li>Properties集合内部提供了很多参数和返回值都是String的方法</li><li><strong>Properties集合</strong>是唯一一个<strong>和IO流结合</strong>使用的集合</li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toots 2020 Dec.07 - Dec.13</title>
      <link href="2020/12/07/Toots-2020-Dec.07-Dec.13/"/>
      <url>2020/12/07/Toots-2020-Dec.07-Dec.13/</url>
      
        <content type="html"><![CDATA[<h1 id="Dec-07"><a href="#Dec-07" class="headerlink" title="Dec.07"></a><strong>Dec.07</strong></h1><hr><ul><li>Sometimes your whole life boils down to one insane move.</li></ul><h1 id="Dec-08"><a href="#Dec-08" class="headerlink" title="Dec.08"></a><strong>Dec.08</strong></h1><hr><ul><li>早就是优势</li><li>互联网人要有互联网意识,抓住任何一个可能的点,避免错过热点</li><li>三百六十行行行出状元,任何看起来不起眼的事情往细了往深了做最终都会有所成绩的</li></ul><h1 id="Dec-09"><a href="#Dec-09" class="headerlink" title="Dec.09"></a><strong>Dec.09</strong></h1><hr><ul><li>竹子用了4年的时间， 仅仅长了3cm， 在第5年开始，却以每天30cm的速度疯狂生长， 仅仅用了6周的时间就长到了15米。 其实，在前面的4年， 竹子把根放土壤里延伸了数百平米。都是为了以后能厚积薄发。 所以，不要浮躁，每天做好努力扎根，努力成长，不要轻言放弃，总有一天，你会发现…原来自己是个土豆</li></ul><h1 id="Dec-10"><a href="#Dec-10" class="headerlink" title="Dec.10"></a><strong>Dec.10</strong></h1><hr><ul><li>「做错」的后悔，可能持续几周、几个月；但「没做」的后悔，可能持续许多年，乃至于成为记忆里一个永久的遗憾。<br>为什么呢？很简单：一件事情做完了，那么它所带来的影响就终止了，哪怕结果不够好，你也可以不断去调整它、优化它；但一件事情没有做，并且再也没机会去做，我们就会对它存在「不确定的损失厌恶」，也就是说：我们知道自己「损失」了，但又不确定「损失了什么」，于是，我们会不断地给这种损失加码，不断地把各种可能的后果，往这个篮子里装。这种感受是最难接受的。</li></ul><h1 id="Dec-11"><a href="#Dec-11" class="headerlink" title="Dec.11"></a><strong>Dec.11</strong></h1><hr><ul><li>似乎所有的小矛盾都可以化为激烈的冲突,而我认为所有的冲突都是可以避免的,避免的方式是在矛盾出现的第一时间就去面对它,逃避只能激化矛盾</li></ul><h1 id="Dec-12"><a href="#Dec-12" class="headerlink" title="Dec.12"></a><strong>Dec.12</strong></h1><hr><ul><li>无论你之前走了那条路,都是你自己走出来的,成功了不要太得意,失败了也不要太苛责,关键是要给自己行走的力量.</li></ul><h1 id="Dec-13"><a href="#Dec-13" class="headerlink" title="Dec.13"></a><strong>Dec.13</strong></h1><hr><ul><li>人和人刚认识的时候最美好.</li><li>行动是打败焦虑最有效的方法.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 句子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toots 2020 Nov.30 - Dec.06</title>
      <link href="2020/11/30/Toots-2020-Nov.30-Dec.06/"/>
      <url>2020/11/30/Toots-2020-Nov.30-Dec.06/</url>
      
        <content type="html"><![CDATA[<p><strong>Nov.30</strong></p><hr><ul><li>想给你颗糖,让你永远不用长大</li></ul><p><strong>Dec.01</strong></p><hr><ul><li>失眠、噩梦、惊醒……你来了,都不存在的</li></ul><p><strong>Dec.02</strong></p><hr><ul><li>不想离开是因为不想一个人去面对那么多未知</li></ul><p><strong>Dec.03</strong></p><hr><ul><li>只要一点勇气，你就可以自己改变生活   &lt;三傻大闹宝莱坞&gt;</li><li>“Find something bigger than yourself ”（找到那些比你自身更宏大的存在）。</li><li>一个人生命中最大的幸运， 莫过于在他的人生中途， 即在他年富力强的时候发现了自己的使命。</li></ul><p><strong>Dec.04</strong></p><hr><ul><li>给你三颗金币,你会回到你的哪一刻,过去、现在还是未来,记住,请想好了再回答.</li><li>爱情是刹那间绚烂的烟火，婚姻是一锅小火慢炖的老鸡汤！</li></ul><p><strong>Dec.05</strong></p><hr><ul><li>作为一个资深的普通人，承认自己的普通与平凡，认清自己，给自己一个准确的定位，也许他们看来是不上进，最起码自己懂</li></ul><p><strong>Dec.06</strong></p><hr><ul><li>人生轨迹的改变,往往是因为你做过的那些看似没有意义的事情</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 句子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员如何把控自己的职业</title>
      <link href="2020/11/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E6%8A%8A%E6%8E%A7%E8%87%AA%E5%B7%B1%E7%9A%84%E8%81%8C%E4%B8%9A/"/>
      <url>2020/11/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E6%8A%8A%E6%8E%A7%E8%87%AA%E5%B7%B1%E7%9A%84%E8%81%8C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="程序员如何把控自己的职业"><a href="#程序员如何把控自己的职业" class="headerlink" title="程序员如何把控自己的职业"></a>程序员如何把控自己的职业</h1><h5 id="转载-2020年08月07日-陈皓"><a href="#转载-2020年08月07日-陈皓" class="headerlink" title="转载: 2020年08月07日 陈皓"></a>转载: <a href="https://coolshell.cn/articles/20977.html" title="17:31">2020年08月07日</a> <a href="https://coolshell.cn/articles/author/haoel" title="View all posts by 陈皓">陈皓</a></h5><img width="196" height="300" src="https://i.loli.net/2020/11/28/hIBGdaOWgXmJFq9.png" style="zoom:80%;" /><p>这篇文章的主要内容主要是我今年3月份在腾讯做的直播，主要是想让一些技术人员对世界有一个大体的认识，并且在这个认识下能够有一个好的方法成就自己。而不是在一脸蒙圈的状态下随波逐流，而日益迷茫和焦虑。直播完后，腾讯方面把我的直播形成文字的形式发了出来，我觉得我可以再做一个精编版。所以，有了这篇文章，希望对大家有帮助。</p><p>对我来说，在我二十多年的工作经历来看，期间经历了很多技术的更新换代，整个技术模式、业务模式也是一直变来变去，我们这群老程序员成长中所经历的技术比今天的程序员玩的还更杂更多。我罗列一下我学过的，而且还被淘汰掉的技术，大家先感受一下。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>MIS应用开发：FoxPro，PowerBuilder，Delphi</span><br><span class="line"><span class="bullet">- </span>OA：Lotus Notes，VBScripts</span><br><span class="line"><span class="bullet">- </span>微软：ODBC/ADO，COM/DCOM，MFC/ATL，J++</span><br><span class="line"><span class="bullet">- </span>服务器：AIX，HP-UX，SCO Unix</span><br><span class="line"><span class="bullet">- </span>Web：CGI，ISAPI，SOAP</span><br><span class="line"><span class="bullet">- </span>RPC：CICS，Tuxedo</span><br><span class="line"><span class="bullet">- </span>J2EE：Websphere，Weblogic</span><br><span class="line"><span class="bullet">- </span>DB：Sybase，Informix </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我想说的是，无论过去还是今天，我们这些前浪和你们后浪所面对的技术的挑战和对技术的焦虑感是相似的，我们那个时候不但玩996，还玩封闭开发（就是一周只能回家一天）。当然，唯一好的东西，就是比起今天的程序员来说，我们那个年代没有像微信、微博、知乎，抖音这些巨大消耗你人生的东西，所以，我们的工作、生活和成长都有很效率，不会被打断、喜欢看书、Google还没有被封……当然，那时代没有StackOverlow和Github这样的东西，所以，能完成的东西或质量都一般。</p><p>当然，这里并不是想做一个比较，只是想让大家了解一下两代程序员间的一些问题各有千秋，大同小异。在整个成长过程中，其实有很多东西是相通的，其本上来说，就是下面的三件事——</p><p><strong>第一</strong>，如果想要把控技术，应对这个世界的一些变化，<strong>需要大致知道这个世界的一些规律和发展趋势，另外还得认识自己</strong>，自己到底适合做什么？在这个趋势和规律下属于自己的发挥领域到底是什么？这是我们每个人都需要了解的。</p><p><strong>第二</strong>，<strong>打牢基础，以不变应万变</strong>，不管世界怎样变化，我都能很快适应它。基础的重要程度对于你能够飞多高是相当有影响的，懂原理的人比不懂原理的人能做出来的事情或是能解决的问题完全是两个层级的。</p><p><strong>第三，提升成长的效率</strong>，因为现在社会的节奏实在太快了，比二十年前快得太多，技术层出不穷，所以我们的成长也要更有效率。效率并不单指的快，效率是怎么样更有效，是有用功除以总功（参看《<a href="https://coolshell.cn/articles/10217.html" title="加班与效率">加班与效率</a>》），怎么学到更有效的东西，或者怎么更有效学习，是我们需要掌握的另一关键。</p><p>下面是我这多年来的一些认识，希望对你有帮助。</p><p>目录</p><ul><li><a href="#%E4%B8%96%E7%95%8C%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF" title="世界发展趋势">世界发展趋势</a></li><li><a href="#%E4%BA%BA%E6%89%8D%E9%9C%80%E6%B1%82" title="人才需求">人才需求</a></li><li><a href="#Google%E8%AF%84%E5%88%86%E5%8D%A1" title="Google评分卡">Google评分卡</a></li><li><a href="#%E8%AE%A4%E8%AF%86%E8%87%AA%E5%B7%B1" title="认识自己">认识自己</a></li><li><a href="#%E6%89%93%E5%A5%BD%E5%9F%BA%E7%A1%80" title="打好基础">打好基础</a></li><li><a href="#%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87" title="学习效率">学习效率</a></li><li><a href="#%E5%B0%8F%E7%BB%93" title="小结">小结</a></li></ul><h4 id="世界发展趋势"><a href="#世界发展趋势" class="headerlink" title="世界发展趋势"></a>世界发展趋势</h4><p><strong>我个人经历的信息化革命应该分成三个阶段：</strong></p><ul><li><strong>1990年代到2000年，这个时代MB时代</strong>，是雅虎、新浪、搜狐、网易门户网站的时代，这个时代就是ISP/ICP互联网提供商，把一些资讯数字化，然后发布到网络上。</li><li><strong>2000年到2010年，这个时代叫GB时代，或是叫多媒体或UGC时代</strong>，上网开始变得普遍了，每个人手里的数码设备开始变得多了起来，可以上传照片，可以上传视频，甚至可以在网上做社交。</li><li><strong>2010年到2020年，这个时代叫TB时代，这过去的十年是移动互联网时代</strong>，移动互联网只需要手机在线，不需要依靠电脑。因为手机随时在线，所以个人的各种各样的数据始终在被收集，只要用户上网就会产生数据，所以人的行为最终也被数字化了。</li></ul><p>所有的硬件和软件都是跟着需要处理的数据而演进的，我们需要更大的带宽，更大的硬盘，更多的处理器……大到一定时候就只能进入分布式化的技术架构了，再大，数据中心也顶不住了，就会要引入更为分布式的边缘计算了。</p><p>另一方面，从业务上来看，<strong>我们可以看到整个世界就在不断地进行数字化，因为，只要数字化了，就可以进行复制传播和计算，只要可以进行计算了，就可以进行数学建模，就可以自动化，只要可以自动化了就可以规模化，只要可能规模化了，就可以改变整个行业</strong>。人类的近代史的大趋势基本上都是在解决能源和自动化的事，源源不断的能源是让机器不知疲倦的前提条件，用机器代替牲口，代替人类进行工作是规模化的前提条件。</p><p>所以，<strong>技术的演进规律基本是自动化加规模化，从而降低成本，提升效率</strong>。这就是为什么世界变得越来越快，人类都快跟不上节奏的原因，主要是整个社会不断被机器、数据所驱动。</p><h4 id="人才需求"><a href="#人才需求" class="headerlink" title="人才需求"></a>人才需求</h4><p>在这个过程中，需要什么样的人？下面是我的一些认识——</p><ul><li><strong>技工</strong>，在机器和自动化面前，肯定是需要能够操作机器的技术工人了，这类人是有技术的劳动力。在编程的圈子里俗称“码农”，他们并不是真正的工程师，他们只是电脑程序的操作员，所以，<strong>随着技术门槛的下降或是技术形式的变更他可能就会变得越来越不值钱，直到被淘汰掉</strong>。</li><li><strong>特种工</strong>，这种人是必须了解原理和解决难题的一类人，他们是解决比较难的、特定的一些技术问题。<strong>当一种技术被淘汰，他并不容易被淘汰，因为他懂原理，原理就是解决问题的能力，是解决问题的套路和方法</strong>。</li><li><strong>工程师</strong>，不但是使用技术，还可以把活儿做好，他们认为代码更多的时间是在维护，这些人使用各种各样的手段和各种技术，精益求精地持续不断地提高代码的易读性、扩展性、可维护性和重用性，这个过程似乎永无止境。对于这些有“洁癖”，有“工匠精神”，有“修养”的技术人员，我们称他们为工程师。<strong>这种人做事又稳又快，而且可以做出很多称手的工具和方法论</strong>。</li><li>再往上是<strong>设计师和架构人员</strong>，这些人主要是开发一些工具，框架，模式，提升软件开发和维护效率，同时也提升用户体验，和提升稳定性、性能、代码重用等，总的来说就是为了降本增效。这类人的工作降低了技术得到门槛，他们把技术门槛降低了以后，就可以把这个技术普及开来，就可以由广大劳工、技工、特殊工人使用了。</li><li>还有一类人是<strong>经理</strong>，经理主要是组织团队、完成项目、创造利润。这类人中，即有身先士卒的leader，也有高高在上的boss，但无论怎么样，这些人只不过是为了让一个公司或是一个团队更好组织在一起的“粘合剂”，这类人只有在大公司中才会变成更有价值。</li></ul><p>这就是我总结的世界需要哪些人才，我们了解这些东西以后大概就明白我们现在所处的位置有什么样的问题，我们应该去什么样的地方。</p><h4 id="Google评分卡"><a href="#Google评分卡" class="headerlink" title="Google评分卡"></a>Google评分卡</h4><p>接下来，我们再来看看Google的SRE的自我评分卡：</p><blockquote><p>0 – 对于相关的技术领域还不熟悉<br>1 – 可以读懂这个领域的基础知识<br>2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节。</p><p>3 – 基本精通这个技术领域，完全不需要别人的帮助<br>4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作。</p><ul><li>对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识。</li><li>对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。</li></ul><p>5 – 对于该技术领域有非常底层的了解和深入的技能。</p><p>6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构<br>7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作。<br>8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施</p><p>9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法。<br>10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人。</p></blockquote><p>SRE需要自评如下这些技术或技能。</p><blockquote><p>– TCP/IP Networking (OSI stack, DNS etc)<br>– Unix/Linux internals<br>– Unix/Linux Systems administration<br>– Algorithms and Data Structures<br>– C/C++<br>– Python<br>– Java<br>– Perl<br>– Go<br>– Shell Scripting (sh, Bash, ksh, csh)<br>– SQL and/or Database Admin<br>– Scripting language of your choice (not already mentioned) _____________<br>– People Management<br>– Project Management</p></blockquote><p>这个评分卡是面试Google前需要候选人对自己的各种技术进行自评，也算是一种技术人员的等级的度量尺，其把技术的能分成11个等级，我用颜色把其它成四大层级，希望这个评份卡能够给你一个能力提升的参考标准。</p><h4 id="认识自己"><a href="#认识自己" class="headerlink" title="认识自己"></a>认识自己</h4><p>认识了世界是怎么发展的，也知道技术人员的种类和层级，那么还要了解一下自己，因为如果不了解自己，那么你也无法找到自己的路和适合自己的地方。</p><p>我觉得，一个人要认识自己就需要认识自己的特长、兴趣、热情、擅长等，下面是一个认识自己的标准方法：</p><ul><li><strong>特长</strong>。首先你要找得到自己特长。你要认识自己的特长，找到自己的天赋，找到你在DNA里比别人强的东西，就拿你的DNA跟别人竞争就好了。所以你要找到自己可以干成的事，找到别人找你请教的事，你身边人找你请教就是说明你有特长。这是找到自己特长非常非常重要，扬长避短。</li><li><strong>兴趣</strong>。如果你没有找到自己特长，就找自己有兴趣有热情的东西。什么叫兴趣？兴趣是再难再累都不会放弃的事。如果你遇到困难就会放弃不叫兴趣，那叫叶公好龙。不怕困难，痴迷其中，就算你没有特长，有了这种特质，你也是头部的人才。</li><li><strong>方法</strong>。如果你没有特长，没有兴趣和热情就要学方法。这种方法就是要有时间观念，要会做计划，要懂统筹、规划对于做过的事情，犯过的错误多总结，举一反三，喜欢自己找答案，自己探究因果关系，这是一些方法，自己总结一些套路。</li><li><strong>勤奋。</strong>如果你没有特长，没有兴趣，也没有方法，你还能做的事就是勤奋，勤奋注定会让你成为一个比较劳累的人，也是很有可能被淘汰的人随着你的年纪越来越大，你的勤奋也会越来越不值钱。因为年轻人会比你更勤奋，比你更勤奋、比你斗志更强，比你能力更强，比你要钱更少的人会出现。勤奋最不值钱，但是只要你勤奋至少能够自食其力。</li></ul><p>以上就是为了应对未来技术变化，作为个人必须要从特长、兴趣、方法一层一层筛选挖掘，<strong>如果没有这些你就要努力和勤奋。就只能接受“福报”了</strong>。</p><p>从我个人而言，我不算是特别聪明的人，但自认为对技术还是比较感兴趣的，难的我不怕。有很多比较难啃的技术，聪明点的人啃一个月就懂了，我不行，我可能啃半年。但是没有关系，知识都是死的，只要不怕困难总有一天会懂的。最可怕是畏难，为自己找借口，这样就不太好了。</p><h4 id="打好基础"><a href="#打好基础" class="headerlink" title="打好基础"></a>打好基础</h4><p>最前面提到我学的各式各样的被淘汰的技术，会让你感觉很迷茫，或是迷失。但前面也提到了“谷歌评分卡”，在这个评分卡中，我们看到了许多基础原理方面的内容，其实要应对未来的变化，很重要的一点就是无招胜有招，以不变应万变。</p><p><strong>变化都是表面的东西，内在的东西其实并没有太多的变化</strong>。理论层面上变得不多，反而形式上的东西今天一个花样，明天一个花样，所以如果要去应对这种变化，就一定要打牢自己的基础，提升内功修养。比如像编程的一些方式和套路，修饰模式原理本质，解耦，提升代码的重用度等。提升代码重用度必须解耦，要跟现实解耦，提升抽象，这些都是一些技术基础。无论用什么语言，都是这么做的。</p><p>打牢基础就可以突破瓶颈，不打牢基础没有办法突破瓶颈。<strong>在技术世界不要觉得量变会造成质变，这是不可能的</strong>。技术这个东西就像搞建筑砌砖头，砌砖头砌的再多也不可能让你能成为一个架构师的，因为你<strong>不懂原理，不懂科学方法，你就不可能成长上去的</strong>，就像学数学一样，当你掌握了微积分这种大杀器后，你解题的能力是无所披靡，而微积分这种方式绝对不是你能“量变”出来的。</p><p>所以你必须学习基础的理论知识，如果不学这些基础理论知识，还要学习解题思路和方法，如果你只学在表面，那么当这个技术的形式有变化，就会发现以前学的都没用了，要重头学一遍。<strong>掌握技术基础可以让自己找到答案和知识，基础是抽象和归纳，很容易形成进一步的推论</strong>。我们学的很多技术实现都逃不脱基础原理，不管是Java，还是其他语言，只要用TCP用的都是相同的原理，逃不出范围，<strong>只要抓住原理，举一反三，时间一长了，甚至还可以自己推导答案</strong>。对于技术的基础，我会把其它成四类：</p><ul><li><strong>程序语言</strong>：语言的原理，类库的实现，编程技术（并发、异步等），编程范式，设计模式……</li><li><strong>系统原理</strong>：计算机系统，操作系统，网络协议，数据库原理……</li><li><strong>中间件</strong>：消息队列，缓存系统，网关代理，调度系统 ……</li><li><strong>理论知识</strong>：算法和数据结构，数据库范式，网络七屋模型，分布式系统……</li></ul><p><strong>这些知识其实就是一个计算机科学专业的学生他所要学习的原理</strong>，但可惜的是，我们的一些学校教得也很糟糕，不但老师能力不足，而且放着世界上最优秀的教课书不用了，一定要自己写一本。讲也讲不全，还有各种错误，哎……总之，如果你学习用用到的教材不行，那么可以肯定的是你的学习效率一定是很糟糕的。这就是为什么我们大学上完了，还是跟个傻瓜一样，还要在工作中再重新自学。</p><p>不过，就算自学，这些基础技术大概需要四五年的时间堆叠。<strong>我工作二十年了，这二十年来基本还是这些原理没变，无论形式怎么变，但是核心永远还是这些，理论创新很难，这是以不变应万变</strong>。</p><h4 id="学习效率"><a href="#学习效率" class="headerlink" title="学习效率"></a>学习效率</h4><img width="384" height="361" src="https://i.loli.net/2020/11/28/DRxabvSh4WQFigY.jpg" style="zoom:80%;" /><p>谈到学习效率，就需要拿出这张学习金字塔的图来了。从图可以看到学习方法分布两层，一种是被动学习，也是浅度学习，听讲，阅读，视听，演示都是在被动学习，而与人讨论，自己动手实践，教授给别人是主动学习。主动学习我们称之为深度学习，如果你不能深度学习，你就不能真正学到东西。这也是你会经常有“学那么多干什么，不用就忘了”，这就是浅度学习的症状了。</p><p>下面，我给出一些我自己觉得不错的学习经验：</p><p><strong>1、挑选一手知识和信息源。</strong>对于学习方法：第一我们一定要到知识源去挑选知识，知识信息源非常关键，二手信息丢失太大了，谭浩强写的书就丢失太多信息了。<strong>目前计算机一手知识基本都是国外的</strong>，所以<strong>英文非常重要</strong>。我鼓励大家一定读第一手的资料。如果你英语有问题，至少要看翻译过来，最好是原汁原味翻译的，不要我理解了给你讲那种，那种也是被别人嚼一遍再讲给你你没有体会，是别人带着你，别人的体会会影响你，也许你的体会会比他更好，因为是你自己总结出来的东西，所以知识源很重要。</p><p><strong>2、注意原理和基础</strong> <strong>第二要注重基础原理</strong>。虽然可以忘记这个技术，但是原理记在心里，我可以徒手实现出来，而且通过原理可以更快学习其他类似的技术。所以原理很重要！当你学会C、C++要学Java和GO都很快。</p><p><strong>3、使用知识图谱</strong> <strong>一定要学会使用知识图</strong>，把知识结构化。从一个技术关键点开始不断地关联和细化下去，比如：关于TCP协议，首先第一个要记住状态图，怎么建立连接，怎么断连接，状态怎么变迁。TCP没有连接，是靠状态维护连接的。其次，要了解TCP怎么保证可靠性，就是丢包以后怎么重传，重传有哪些技术点。然后，重传会让你联想到拥塞控制，拥塞控制到滑动窗口……。这基本就是TCP的所有东西了，找到关键点，然后顺着这个脉络一点点往下想，通过知识图关联就可以进行顺藤摸瓜。我们不需要记所有知识，那些<strong>手册的知识不需要记，你知道在哪里能找到就可以了</strong>。你脑子里面要有地图，学一个东西就跟在城市生活一样，闭上眼睛就知道地图，A点到B点怎么去大概方向要知道。我在北京我去广州，广州在南边，我大概坐飞机还是火车要心里有数。。</p><p><strong>4、学会举一反三</strong>。就是用不同方法学一个东西，比如说学TCP协议，看书是一种方法，编程是另外一种方法，还有用做Debug去看的，用不同方法学一个东西会让你更加熟悉，你学一个知识的同时把周边也学了。比如说学前端能不能把HTTP学一下，比如说长连接、短连接，包括hp1、hp2有一些不一样的东西。</p><p><strong>5、总结和归纳。</strong>只有学会总结和归纳，才能形成自己的思维框架、自己的套路、自己的方法论，以后学这个东西应该怎么学。就像学一门新的语言，不管GO语言，还是Rust语言，第一件事情就是了解内存是怎么管理的，数据类型什么样，第二是泛型怎么搞，第三是并发怎么弄。还有一些抽象怎么弄，比如说怎么解耦，怎么实现多态？套路这种东西只有学的多了以后才能形成套路，如果你只学会一门语言不会有套路，你要每年学门语言，不用学多精，你思考这个语言有什么不一样，为什么这个这种有玩法，那个有那种玩法，这些东西思考多了套路方法论就出来了。比如说Windows和Linux有什么不同，Linux和Unix又有什么不同？只有总结自己的框架、套路和方法，这些才永远不会被淘汰。</p><p><strong>6、实践和坚持。</strong>剩下就是多做多练，多坚持，只有实践才会有经验，只有锻炼了才能够把自己的脂肪变没，所以，<strong>要把知识变成技能必须练</strong>，就像小学生学会加减乘除，还是要演练，必须多做题，题目做得多了，自然掌握得好。要挑选好的知识源，注重原理技术，有一些原理的基础的书太枯燥，但是我告诉你学习这些基础太值得投入时间，搬砖赚几十元不值得，因为赚的是辛苦钱，老了就赚不了，必须要赚更有能力的钱，这是学习投资。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>好了，该到这篇文章收尾的时候了，小结一下，如果你想更好的把握时代，提升自己，你需要知道这个时代的趋势是什么，需要什么样的人，这些人需要什么样的能力，这些能力是怎么获得的，投入到基础知识的学习就像“基建”一样，如果基础不好，不能长高，学习能力也是需要适应这个快速时代的重要的基础能力，没有好的学习能力，很快就会掉队被淘汰。</p><p>这些东西，是我从业二十年来的总结和体会，希望对你有用。</p><p>（全文完）</p><p><img src="https://i.loli.net/2020/11/28/vnUIWra5ktu3ZmE.jpg" style="zoom:67%;" /> <img src="https://i.loli.net/2020/11/28/UMAHDs2Z4RzOgT1.jpg" style="zoom:67%;" /><br>关注CoolShell微信公众账号和微信小程序</p><p><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toots 2020 Nov.23 - Nov.29</title>
      <link href="2020/11/23/Toots-2020-Nov.23-Nov.29/"/>
      <url>2020/11/23/Toots-2020-Nov.23-Nov.29/</url>
      
        <content type="html"><![CDATA[<p><strong>Nov.23</strong></p><hr><ul><li><p>遇到问题为什么要哭,哭有什么用</p><p>可是,哭本来就不是用来解决问题的~    </p><p>#电报频道</p></li><li><p>有时父母和小孩的某些情感连接真的很神奇，即便不在一起父母好像都能感知到你的喜怒哀乐，在你状态糟糕的时候就能收到妈妈问的一句“最近还好吗？”</p><p>我不是一个经常会主动联系家人的人，倒也不是不记挂，只是好像骨子里有些疏离，即便是家人，我也很少去主动拉进距离。</p><p>妈妈今天打来电话，问我在做些什么，最近课多不多，吃得如何。我一一回答，然后妈妈问我“你最近还好吗？”当下好像全身的血液滞住了，我说“嗯，挺好的。”不过其实一直也不大好，但妈妈问我这一句的时候我想她一定有感觉到些什么吧，这种感觉很奇妙，好像血浓于水的同时情感也彼此联通一般。</p><p>想起今年暑假的时候，我像一摊烂泥，一团乱麻，过的特别糟糕。那段时间不知道为什么，妈妈给我通电话也很多，总是让我多出去走走，多联系朋友，给自己买点衣服鞋子。有一次妈妈在电话里跟我说，你有什么都可以跟爸爸妈妈说的，我知道你不是一个外向的爱说的小孩，但也不要压抑自己。听到的一瞬间我就开始止不住地掉眼泪，我把手机拿远，拿着纸捂住鼻子嘴巴不要哭出声音，怕自己说话会被妈妈发现在哭，就只是闷闷的回答“嗯。”</p><p>“你想吃什么吗？”妈妈轻轻地问我，“想吃我就给你买。”我说没什么想吃的呢，妈妈说，那你自己在学校好好吃饭，注意身体啊。</p><p>“你看你，我不给你打电话你就不会打给我。”妈妈抱怨道。我沉默着，“以后没事也给我打电话聊聊天啊。”</p><p>我会尽量的妈妈，只是，我害怕自己会绷不住那根弦，我不想让你担心我呀，所以什么都不说就会让你觉得我过得挺好的，我也希望你们觉得我挺好的。</p><p>谢谢你啊妈妈。   </p><p>#陌生人日记</p></li><li><p>心里没有了波涛汹涌,只是觉得心理突然空了,我不确定自己能用多少时间把你彻底忘了,也不敢保证我就能真的把你忘了,我只能像现在这样,不吵不闹,不悲不喜,安安静静的与你,再无任何交集.</p><p>#电报</p></li><li><p>最开始只是一句简单的争吵</p><p>他默不作声，希望与人为好</p><p>他们的眼神从轻蔑到好奇，再到兴致盎然</p><p>可怕，好像找到玩物的猎豹</p><p>他向身边的人倾诉，得到的安慰如此潦草</p><p>“为什么只有你被挑上了，别人都没事？！”</p><p>“忍一忍，等毕业就好”</p><p>老师说：孩子还小，难免小打小闹</p><p>父亲别过脸：别惹事，我们没钱，处理不了</p><p>母亲哭着说：忍一忍，学习最重要</p><p>算了，算了</p><p>不过是起了个不太好听的外号</p><p>不过是小小的造了个谣</p><p>不过是新年还没到，提前放了个鞭炮</p><p>他默不作声，怀疑着自己的感觉</p><p>剪头发，抽脸不过是同学开个玩笑，</p><p>当众脱衣只是同学帮助检查身体</p><p>被狠踹几脚只是他们没有把握好分寸</p><p>要怪只怪自己心态不好</p><p>可是怎么办呢</p><p>脸上的红肿经久不消</p><p>厕所聆听了他的每一次哀嚎</p><p>班长视若无睹知情不报</p><p>警惕着身后，生怕一个飞踹他就被踢倒</p><p>直到他拿起了手里的弹簧刀</p><p>起码让暴徒知道</p><p>他们的作为</p><p>不应该只是口头警告</p><p>父母不懂，那么乖的一个孩子怎么就变成了这样</p><p>老师将他赶出了学校：孩子思想太危险，不好管教</p><p>20年后，看着越来越多的校园霸凌报道</p><p>听着身边人的惋惜</p><p>庆幸自己的理智，不然只能出现在法制频道</p><p>父母惋惜着他的过往：当时再忍忍，拿到毕业证多好</p><p>他笑了笑</p><p>午夜梦回，大汗淋漓，噩梦做够一万次，也就习惯了？</p><p>作者：朱一旦的枯燥生活<br>来源：知乎<br>话题：校园霸凌</p></li></ul><p><strong>Nov.24</strong></p><hr><ul><li>如果他真的那么爱你,他会把你介绍进他的生活圈子里,不会连公开的勇气都没有,爱情本应该是一件公开 温暖的事情,何必委屈自己附和一段不见光的感情,你真正需要的是一个,灯光再亮也会抱住你的人</li><li>你低估了我想陪你走下去的决心,而我高估了我在你心理的位置,正如你是我患得患失的梦,而我是你可有可无的人,毕竟这穿越山河的剑,刺的都是用情至极的人</li><li>仗义每多屠狗辈,负心多是读书人</li><li>书籍的全部意义在于使人善用自己的孤独</li></ul><p><strong>Nov.25</strong></p><hr><ul><li>红雨随心翻作浪,青山着意化为桥</li></ul><p><strong>Nov.26</strong></p><hr><ul><li><p>好多人不开心了遇到难过的事情了会到李文亮医生的微博下面留言，顺带看看别人的留言互相鼓励一下，生活中最感动的莫过于这种来自陌生人的温暖和善意了吧</p></li><li><p>人的棱角慢慢消失,绝多数不是被眼前的丑恶给击碎的,而是被身后的愚昧和嘲弄给削平的.</p><p>若这个世界是一个大泥潭,有的人在里面打滚,脏的不亦乐乎,有的人身处最中央,致力于把身边的肮脏抹掉,却被视作疯子,而我只想拼尽全力爬出去,在泥潭的边缘冷眼旁观,我对这些污浊无能为力,只求自己能干净一点.</p><p>罗曼罗兰说过,世上只有一种英雄主义,即是认清生活本质后依然热爱生活.</p><p>调子起的太高,我自认为做不到,所以对于我们这些无名之辈,能够认清生活本质和生活和平共处,已是我们能做到最大的努力.</p><p>上帝的归上帝,撒旦的归撒旦,大概就是这</p></li></ul><p><strong>Nov.27</strong></p><hr><ul><li><img src="https://i.loli.net/2020/11/28/KhSTfFbLPuD8CA7.jpg" alt="daoli" style="zoom:67%;" /></li></ul><p><strong>Nov.28</strong></p><hr><ul><li>凡所有相,皆为虚妄.</li><li>不要虚掷你的黄金时代，不要去倾听枯燥乏味的东西，不要设法挽留无望的失败，不要把你的生命献给无知、平庸与低俗。</li></ul><p><strong>Nov.29</strong></p><hr><ul><li><p>好人之所以是好人，是因为他不做好事就活不下去；坏人之所以是坏人，是因为他不做坏事就活不下去。所以好人不需要夸奖，坏人不需要惩罚。好人做好事，是因为他心中有一种感情，做了好事才能去满足这种感情，如果不做好事，他会很难过。坏人同样的道理。所以没必要去分别对待，就像每个人的性格不同，大家都按照自己的个性去做相应的事。那么还何必去分对错呢？</p><p><strong>善只是善，不要讲结果，更不要根据当时的结果分大善和小善。你认为这件事是善，那就去做，即使别人不理解，那也无妨。毕竟对每个人来讲，善都是自己的私事。</strong></p><p>所以，关键是：<strong>你想不想善。想善并不意味着你是个好人，不想善也不并意味着你是个坏人。只是选择不同、活法不同而已。</strong></p><p><a href="http://www.zreading.cn/archives/7977.html">&lt;&lt;关于善，关键是：你想不想&gt;&gt;</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 句子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toots_2020_Nov.22</title>
      <link href="2020/11/22/Toots-2020-Nov-22/"/>
      <url>2020/11/22/Toots-2020-Nov-22/</url>
      
        <content type="html"><![CDATA[<ul><li>心里没有了波涛汹涌，只是觉得心里突然空了，我不确定自己能用多少时间把你彻底忘了，也不敢保证我就能真的把你忘了，我只能像现在这样，不吵不闹，不悲不喜，安安静静的与你，再无任何交集。</li></ul><a id="more"></a><ul><li>如果他真的有那么爱你，他会把你介绍进他的生活圈子里，不会连公开的勇气都没有，爱情本应该是一件公开，温暖的事情，何必委屈自己去附和一段不见光的感情，你真正需要的是一个，灯光再亮也会抱住你的人。</li><li>我依旧敢和生活顶撞，敢在逆境里撒野，直面生活的污水，永远乐意为新的一轮月亮和日落欢呼。</li><li>仗义每多屠狗辈，负心多是读书人。</li><li>满眼都是你又怎样，深情专一又如何？最后还不是被辜负？在这个暧昧横行的年代，深情，不过是个笑话</li><li>你低估了我想陪你走下去的决心，而我高估了我在你心里的位置，正如你是我患得患失的梦，而我是你可有可无的，毕竟这穿越山河的剑，刺的都是用情至极的人</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 句子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo的博客搭建_win10_github</title>
      <link href="2020/11/21/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA_hexo_github_win10/"/>
      <url>2020/11/21/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA_hexo_github_win10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为有的内容我电脑已经有了,所以部分步骤不是很完整~我主要是在自己操作过程中略微记录了一下方便后期参考.如果有问题可以参考一下<a href="https://hexo.io/zh-cn/docs/setup">hexo</a>网站,里面内容也比较完整,或者email联系我也ok,如果有空也会尽量回复的………</p></blockquote><a id="more"></a><h2 id="1-node的安装"><a href="#1-node的安装" class="headerlink" title="1.node的安装"></a>1.node的安装</h2><ol><li><p>下载<a href="http://nodejs.org/">node.js</a></p></li><li><p>直接安装</p></li><li><p>配置系统环境变量–在<code>系统变量</code>中直接在<code>path</code>中添加,直接复制你的安装目录即可.</p><p><img src="https://i.loli.net/2020/11/20/TOtf2oSmxQF5l6N.png" alt="image-20201120223735403"></p></li><li><p>测试是否配置完成,在<code>cmd</code>窗口输入<code>node -v</code>看是否可以正常显示版本,输入<code>npm -v</code>看是否成功显示npm版本,具体的方式百度到处都有.</p></li></ol><h2 id="2-github的注册"><a href="#2-github的注册" class="headerlink" title="2.github的注册"></a>2.github的注册</h2><ol><li><p>注册<a href="">github</a></p></li><li><p>创建一个新的repository,这里注意如果需要使用github pages的话那么名称必须是<code>你的用户名.github.io</code>,这样你配置完之后可以直接通过这个地址访问你的博客.(我的名称如下)</p><p><img src="https://i.loli.net/2020/11/20/lXKPk6RH7oEc89v.png" alt="image-20201120224739138"></p></li><li><p>顺手点击一下,下一步git配置里面要用到这</p><p><code>点右上角头像–settings–SSH and GPG keys</code>准备输入一会的地址</p></li></ol><h2 id="3-win10系统git环境的安装和配置"><a href="#3-win10系统git环境的安装和配置" class="headerlink" title="3.win10系统git环境的安装和配置"></a>3.win10系统git环境的安装和配置</h2><ol><li><p>下载<a href="https://git-scm.com/download/win">git</a>并安装好</p></li><li><p>cmd命令行打开,输入<code>git version</code>看是否显示版本信息,没有显示的话,进入系统环境配置,在path中添加git 的安装目录</p><img src="https://i.loli.net/2020/11/21/ArfYKebXzIuMTWs.png" alt="image-20201121020448803" style="zoom:67%;" /></li><li><p>打开git bash,然后配置用户名和邮箱地址cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##配置用户名</span><br><span class="line">git config --global user.name &quot;fenda&quot;  </span><br><span class="line">#配置邮箱</span><br><span class="line">git config --global user.email “fenda.abc@gmail.com”</span><br><span class="line">#git push的时候记住用户名和密码</span><br><span class="line">git config --global credential.helper store </span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>如果你之前用过git,那么直接寻找本地的<code>.gitconfig</code>文件看里面你配置的用户名和邮箱地址或者<code>cd ~/. ssh #检查本机已存在的ssh密钥</code></p></li><li><p>如果提示<code>如果提示：No such file or directory</code> 说明你是第一次使用git;输入<code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code>,然后需要输入保存的位置和设置密码,这里可以不用输入直接连续回车三次也行,最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入<code>个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</code>将刚复制的内容粘贴到key那里，title随便填，保存。如下图所示</p><img src="https://i.loli.net/2020/11/20/Min4AHDOJSumRKV.png" alt="image-20201120225731648" style="zoom:50%;" /></li><li><p>测试是否可以使用:在git bash中输入<code>ssh -T git@github.com</code>  注意邮箱地址不用改,直接复制即可,看是否如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p><blockquote><p>Hi abcdefc! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息key添加完成</p></li><li><p>然后配置ssh,</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh #进入ssh目录</span><br><span class="line">sudo touch config #新建ssh的配置文件</span><br><span class="line">sudo gedit config #修改ssh的配置文件</span><br><span class="line">sudo chmod <span class="number">600</span> config #添加权限</span><br></pre></td></tr></table></figure><p><strong>config</strong>文件的内容：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com  </span><br><span class="line">User 你的注册邮箱 </span><br><span class="line">Hostname ssh.github.com  </span><br><span class="line">PreferredAuthentications publickey  </span><br><span class="line">IdentityFile ~/.ssh/id_rsa  </span><br><span class="line">Port <span class="number">443</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssh git@github.com</span><br></pre></td></tr></table></figure><p>如果看到下图,说明SSH已配置成功！</p><p><img src="https://i.loli.net/2020/11/21/c2GxYlBhIEyH8Dt.png" alt="image-20201121032150442"></p></li></ol><h2 id="4-hexo的安装"><a href="#4-hexo的安装" class="headerlink" title="4.hexo的安装"></a>4.hexo的安装</h2><blockquote><p>这一步可以在安装node.js的时候一块安装了</p></blockquote><ol><li><p>打开命令行窗口输入:<code>npm install -g hexo-cli</code>,等待命令执行完成,默认安装在nodejs的目录里面,然后需要到系统环境变量中配置环境,确保cmd窗格能直接识别命令,我这里等待的时间比较久(网友好多直接用cnpm安装的,可能会快点,可以借鉴)</p></li><li><p>用cd命令切换到你需要保存blog的位置,例如我的在<code>D:\Documents\blog</code>,我直接切换到<code>D:\Documents</code>,然后执行<code>hexo init blog #(这个blog是我博客的文件夹名,你可以用你自己的)</code>,这里也等待的比较长的时间</p></li><li><p>然后<code>cd blog</code>,进入blog目录</p></li><li><p>执行<code>npm install</code>,执行完成后的目录如下,可以用ls查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></li><li><p>这些目录的具体说明在hexo网站有,其中</p><ol><li><code>source</code>中的<code>_posts</code>中是已经保存的Markdown文件保存的地方,</li><li><code>themes</code>中是主题,默认已经有了一个,我后面会切换一个</li><li><code>_config.yml</code>是配置文件,详细的信息建议看<a href="https://hexo.io/zh-cn/docs/configuration">官网</a>,你博客的名字,使用的语言,时区,以及最后上传到github的位置都是在这里面进行配置的…….现在可以先不看,一会只修改一下github相关的东西和主题即可,剩下的东西后面再慢慢研究,其实我现在也是半斤八两,不过边学边卖吗,不懂就查~~</li></ol></li><li><p>回到git bash中,</p><ol><li><p>使用<code>hexo g</code>,将_post文件夹中已经有的md文件进行渲染,</p></li><li><p>使用<code>hexo s</code>,启动hexo博客的本地服务器,可以看到提示的本地访问地址,复制到浏览器访问<code>http://localhost:4000</code>,执行命令如下</p><img src="https://i.loli.net/2020/11/20/u4Rc6JULbo1dBWn.png" alt="image-20201120232225288" style="zoom:80%;" /><p>网页效果图如下:</p><img src="https://i.loli.net/2020/11/20/KDExGhbkXFzg7aw.png" alt="image-20201120233407339" style="zoom:67%;" /></li><li><p>使用<code>hexo clear</code>,可以将缓存进行清除</p></li><li><p>使用<code>hexo g -d</code>执行生成和上传github的命令,</p><ol><li><p><code>注意</code>需要确保首先github上面已经创建了repository,公开的(如果私有的话使用github pages需要付费),且命名符合上面注册时候我写的命名规则,</p></li><li><p><code>注意</code>已经安装配置了本地的git环境</p></li><li><p><code>注意</code>上传github需要先安装相关插件,在blog目录下执行<code>npm install hexo-deployer-git --save</code>,这里有可能报错,提示权限不足等等,可以重新使用管理员权限切换到相应目录然后执行上面的命令</p></li><li><p><code>注意</code>已经配置了本地<code>_config.yml</code>中的git相关设置,如下图所示</p><img src="https://i.loli.net/2020/11/21/nzBMQr1Zkc8iNHF.png" alt="image-20201121032614470" style="zoom:80%;" /></li><li><p>第一次执行<code>hexo g -d</code>命令会提示输入github用户名和密码~</p></li><li><p>执行<code>hexo g -d</code>命令,执行完效果如下</p><img src="https://i.loli.net/2020/11/20/FiA1rnHQ4Xc35dM.png" alt="image-20201120234305198" style="zoom:80%;" /></li><li><p>浏览器直接访问<code>你的用户名.github.io</code>,我的是<code>https://fendaabc.github.io/</code>,效果如下(我这在<code>_config.yml</code>中修改了一部分的页面信息,下面会放的)</p><p><img src="https://i.loli.net/2020/11/20/Wq5LK2YnmykvU9c.png" alt="image-20201120234627496"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">芬达里没有泡泡</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">来杯可乐,不加糖</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">芬达</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure></li><li><p>到这里其实最基本的功能已经完成了,本地生成的markdown文件已经可以在浏览器进行显示了</p></li></ol></li></ol></li></ol><h2 id="5-常规的操作步骤"><a href="#5-常规的操作步骤" class="headerlink" title="5.常规的操作步骤"></a>5.常规的操作步骤</h2><ol><li>其实已经可以基本使用联网版本的个人博客了,剩下的功能就留给我们慢慢探索了</li><li>常规使用方法<ol><li>git bash进入blog目录,然后<code>hexo n 博客名字</code>,生成新博客,然后打开在里面可以直接进行编辑,默认生成已经有了时间和标题,格式相对完整</li><li>写完以后,<code>hexo g</code>生成html文件,<code>hexo s</code>本地服务打开进行预览</li><li>不预览的话直接<code>hexo g -d</code>生成并上传</li><li>为了避免默认主题上传后全文展示,可以在合适的地方使用<code>&lt;!--more--&gt;</code>,将前面部分作为摘要展示,后面部分需要点开全文进行展示…………..但这块应该可以通过别的主题直接进行实现,而且默认主题并不是很好看</li></ol></li><li>但是现在还存在一些问题,第三方的主题上传github后显示效果和本地不一样,域名解析还存在一定问题,还得修改一下</li></ol><h2 id="6-第三方主题maupassant的安装"><a href="#6-第三方主题maupassant的安装" class="headerlink" title="6.第三方主题maupassant的安装"></a>6.第三方主题<strong>maupassant</strong>的安装</h2><blockquote><p>我使用的主题名字是<strong>maupassant</strong>,<a href="https://www.haomwei.com/technology/maupassant-hexo.html">安装步骤页面</a>和<a href="https://github.com/tufu9441/maupassant-hexo">github页面</a>,效果图如下</p><img src="https://i.loli.net/2020/11/21/whaLIOoPkxteRVD.png" alt="image-20201121000028938" style="zoom:50%;" /></blockquote><ol><li><p>命令行切换到blog目录,然后输入一下命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant  </span><br><span class="line">npm install hexo-renderer-pug --save  #会提示用管理员权限运行</span><br><span class="line">npm install hexo-renderer-sass --save  </span><br></pre></td></tr></table></figure></li><li><p>编辑Hexo目录下的 <code>_config.yml</code>，将<code>theme</code>的值改为<code>maupassant</code>。</p></li><li><p>确保刚刚pull的theme是在blog的根目录,并且maupassant和landscape在同一个文件夹中</p></li><li><p>执行<code>hexo clear</code>清理缓存,然后<code>hexo g</code>重新生成 ,再<code>hexo s</code>打开本地服务,通过浏览器查看<code>http://localhost:4000</code>是否已经成功启用新版主题.如下图</p></li></ol><img src="https://i.loli.net/2020/11/21/3EUrVw1KYRgyiCG.png" alt="image-20201121005907303" style="zoom:67%;" /> 5. 执行`hexo d`,将改变后的文件进行上传,访问就好<ol start="6"><li><p><code>注意</code>:使用后发现网页乱码,无法渲染,找到解决办法是—–将本地blog目录下的``_config.yml<code>文件中的</code>per_page:20<code>改成</code>5`或者更小就正常加载了,如下:</p><img src="https://i.loli.net/2020/11/21/zMtvwxZnHiEmNu1.png" alt="image-20201121173025899" style="zoom:67%;" /></li></ol><h2 id="6-第三方主题light安装"><a href="#6-第三方主题light安装" class="headerlink" title="6.第三方主题light安装"></a>6.第三方主题light安装</h2><blockquote><p>项目地址:<a href="https://github.com/hexojs/hexo-theme-light">https://github.com/hexojs/hexo-theme-light</a></p></blockquote><ol><li>安装<code>git clone --depth 1 https://github.com/hexojs/hexo-theme-light themes/light</code></li><li></li></ol><h2 id="6-第三方主题next的安装"><a href="#6-第三方主题next的安装" class="headerlink" title="6.第三方主题next的安装"></a>6.第三方主题<strong>next</strong>的安装</h2><blockquote><ul><li><p>步骤可参见<a href="https://github.com/next-theme/hexo-theme-next/blob/master/docs/zh-CN/README.md">github</a></p></li><li><p>m每个月的next更新: <code>npm update hexo-theme-next</code></p></li></ul></blockquote><h2 id="7-绑定个人域名"><a href="#7-绑定个人域名" class="headerlink" title="7.绑定个人域名"></a>7.绑定个人域名</h2><ol><li><p>可以在阿里云里购买自己喜欢的<a href="https://wanwang.aliyun.com/">域名</a></p></li><li><p>购买完之后到控制台添加域名解析地址<img src="https://i.loli.net/2020/11/21/aoDOhCINxgZmWAF.png" alt="image-20201121011942199" style="zoom:50%;" /></p><ol><li><strong>A记录</strong>:用本地cmd ping一下自己的<code>用户名.github.io</code>,会得到一个IPV4的地址,将这个地址填写到记录值</li><li>CNAME记录:主机记录是www,记录值是<code>用户名.github.io</code>,</li><li>剩下应该还有一些,但我还搞不懂,就没弄</li><li>会到github页面,点开你的blog的repository,进入setting,找到GitHub Pages,然后在下面写上你购买的域名<img src="https://i.loli.net/2020/11/21/3JgrIkYClVEcfB6.png" alt="image-20201121014244889" style="zoom:67%;" /></li><li>通过个人域名直接在浏览器进行博客访问.</li><li><code>注意</code>:使用了几次发现这里绑定的域名会自动消失,然后导致访问域名解析不到地址,解决办法是在本地blog<code>\source</code>目录下新建<code>CNAME</code>文件,里面写上你购买的域名,例如我的<code>fenda.info</code>,这样就解决了域名消失的问题,原理不懂,但目前是这样解决的~</li></ol></li></ol><h2 id="8-基于maupassant主题的页面调整"><a href="#8-基于maupassant主题的页面调整" class="headerlink" title="8.基于maupassant主题的页面调整"></a>8.基于maupassant主题的页面调整</h2><p><strong>我现在使用的主题是maupassant,所以下面的调整都是在这个前提下进行的,基本所有功能默认都集成好了,直接在主题配置文件中启用就行了,因为我比较笨,所以记录一下开启的过程</strong></p><blockquote><ul><li><input checked="" disabled="" type="checkbox"> <ol><li>网页左上角小logo</li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="2"><li>标签栏 例如:java  doc Android等的显示</li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="3"><li><del>谷歌搜索实现</del></li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="4"><li>本地搜索功能实现,搜索已经存在的文档</li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="5"><li>文档页面的美化,统一前端页面,所有的文档尽量除了标题和描述信息以外其他都不展示,避免页面混乱–</li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="6"><li>友情链接</li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="7"><li>文章初始化时候_日期-时间-标签-目录等的在哪设置:<a href="https://hexo.io/zh-cn/docs/front-matter">https://hexo.io/zh-cn/docs/front-matter</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="8"><li>文章代码块样式的美化:<a href="https://hexo.io/zh-cn/docs/tag-plugins">https://hexo.io/zh-cn/docs/tag-plugins</a>  </li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="9"><li>启用评论系统</li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="10"><li>文字字数阅读时间显示和浏览量显示</li></ol></li><li><input disabled="" type="checkbox"> <ol start="11"><li>目录美化,尽量将目录往右边放,目前是直接出现在正文一开始</li></ol></li><li><input disabled="" type="checkbox"> <ol start="12"><li>搜索引擎收录</li></ol></li></ul></blockquote><h3 id="1-网页左上角小logo的添加"><a href="#1-网页左上角小logo的添加" class="headerlink" title="1. 网页左上角小logo的添加"></a>1. 网页左上角小logo的添加</h3><p>制作一个你需要的logo,命名为<code>favicon.ico</code>,放在<code>\source</code>目录下,然后重新生成以后就好了</p><p><img src="https://i.loli.net/2020/11/21/gjXmZFHLGazQwYh.png" alt="image-20201121172231087"></p><h3 id="2-标签栏设置"><a href="#2-标签栏设置" class="headerlink" title="2. 标签栏设置"></a>2. 标签栏设置</h3><blockquote><p>操作在Markdown文档所在目录执行,即<code>blog\source\_posts</code>目录</p></blockquote><ol><li><h3 id="3-谷歌搜索实现"><a href="#3-谷歌搜索实现" class="headerlink" title="3.谷歌搜索实现"></a>3.谷歌搜索实现</h3></li></ol><h3 id="4-本地搜索"><a href="#4-本地搜索" class="headerlink" title="4.本地搜索"></a>4.本地搜索</h3><p>主题配置文件中<code>self_search</code>标签配置如下:</p><img src="https://i.loli.net/2020/11/22/SFUwtdvm5iyzRM7.png" alt="image-20201122222729500" style="zoom:67%;" /><h3 id="5-主页显示文章的排版整齐-可参见下面7中post的模板"><a href="#5-主页显示文章的排版整齐-可参见下面7中post的模板" class="headerlink" title="5.主页显示文章的排版整齐(可参见下面7中post的模板)"></a>5.主页显示文章的排版整齐(可参见下面7中post的模板)</h3><p>我希望文章的显示效果和我看到的某个大佬的,如下图,避免首页看到每个文章显示有的长有的短,有的还带超链接,主要还是希望看起来整齐一些,这里两种解决办法:</p><ol><li><p>可以在文章的front-matter中(我是在post模板中,看第7项下面我的post里的内容)填写一项<code>description: 你想显示的句子</code>来设置你想显示的摘要，</p></li><li><p>直接在文章内容中插入<!--more-->以隐藏后面的内容,前面的内容就会作为摘要在首页显示。</p><p>若两者都未设置，则自动截取文章第一段作为摘要。</p></li></ol><h3 id="6-友情链接"><a href="#6-友情链接" class="headerlink" title="6.友情链接"></a>6.友情链接</h3><p>在主题配置文件中,有个<code>links</code>标签,在下面按照格式编辑就行.</p><img src="https://i.loli.net/2020/11/22/pgCERI9PoUXYGT4.png" alt="image-20201122190232959" style="zoom:75%;" /><h3 id="7-文章初始化时候的日期时间标签"><a href="#7-文章初始化时候的日期时间标签" class="headerlink" title="7.文章初始化时候的日期时间标签"></a>7.文章初始化时候的日期时间标签</h3><ol><li><p><strong>文章标题</strong>:在正文中直接用—分隔开,或者是在命令中用<code>hexo n 文章标题</code>生成,我发现如果文章命名存在空格的话显示时候存在问题,有的不显示文章正文,具体原因不了解,我把文章标题的空格都用下划线替换了</p></li><li><p><strong>标签</strong>:需要先在主题配置文件中启用<code>widgets</code>中的<code>tag</code>标签(默认已经启用了),然后根目录命令行输入</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">page</span> tags</span><br></pre></td></tr></table></figure><p>成功后会提示</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~<span class="regexp">/Documents/</span>blog<span class="regexp">/source/</span>tags/index.md</span><br></pre></td></tr></table></figure></li></ol><p>   然后再在根目录的<code>scaffolds</code>文件夹中编辑<code>post.md</code>文件模板,在文章中添加tag格式需要如下:</p>   <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tags:</span></span><br><span class="line">- java</span><br><span class="line">- Android</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>日期</strong>:本身的post模板文件已经包含了日期函数,所以当用<code>hexo n 文章题目</code>生成的文章中默认包含了日期,如果自己手动创建的话那么文章开头至少需要包含<code>title</code>和<code>date</code>两项,</p></li><li><p><strong>目录</strong>:post中使用<code>toc:true</code>实现</p></li><li><p>下面是我post的模板,里面包括了标题,日期,评论,摘要,目录和标签</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;To the time to life, rather than to life in time.&quot;</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="8-代码块美化"><a href="#8-代码块美化" class="headerlink" title="8.代码块美化"></a>8.代码块美化</h3><p>我的代码格式不规范,我基本使用反引号来实现代码功能,所以代码变色没有体现,后面再说吧,这个现在无所谓</p><h3 id="9-评论-使用的Disqus"><a href="#9-评论-使用的Disqus" class="headerlink" title="9.评论-使用的Disqus"></a>9.评论-使用的Disqus</h3><p>在主题配置文件中有<code>Disqus</code>的标签,先到官网<a href="https://disqus.com/">注册登录</a>,然后点击<code>I want to install</code>,在下个页面有个<code>Website Name</code>这个名字一定要记住(其他随便填,提交以后后面的页面没有我们的系统因为本身hexo已经集成了这个评论系统,所以后面的随便填写就ok,或者直接跳过好像也行吧),需要在主题文件的标签后面写上这个名字,比如我写的名字是<code>fenda</code>,所以主题文件里我写的就是fenda,如下图所示,然后post里我配置了<code>comments: true</code>,就是评论默认开启,这样评论系统就可以使用了.</p><p>注册网站中:</p><img src="https://i.loli.net/2020/11/22/sOetU5xGMqPBNng.png" alt="image-20201122222137750" style="zoom:50%;" /><p>主题配置文件中:</p><img src="https://i.loli.net/2020/11/22/KjzeVYEgAp2FoLl.png" alt="image-20201122222244821" style="zoom:80%;" /><p>实现的效果:</p><img src="https://i.loli.net/2020/11/22/kKV6YJ7xPoM3XiR.png" alt="image-20201122222514522" style="zoom: 67%;" /><h3 id="10-文字字数统计和浏览量统计"><a href="#10-文字字数统计和浏览量统计" class="headerlink" title="10.文字字数统计和浏览量统计"></a>10.文字字数统计和浏览量统计</h3><p>主题配置文件中,有个<code>wordcount</code>标签,将后面改成<code>true</code>,</p><p><img src="https://i.loli.net/2020/11/22/Thg16UIDENr2mdL.png" alt="image-20201122190418057"></p><p>然后命令行打开切换到博客根目录,执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p>就好了,直接在主题配置文件打开busuanzi的配置,就能显示浏览量了.效果如下图:</p><img src="https://i.loli.net/2020/11/22/WsOkRD65XIqPUAa.png" alt="image-20201122225310550" style="zoom:80%;" /><h3 id="11-目录美化"><a href="#11-目录美化" class="headerlink" title="11.目录美化"></a>11.目录美化</h3><blockquote><p>参考网页:<a href="https://www.jianshu.com/p/693afdcef95f">https://www.jianshu.com/p/693afdcef95f</a></p><p>半夜实验了一次,没成功,先放下了</p></blockquote><h3 id="12-搜索引擎收录"><a href="#12-搜索引擎收录" class="headerlink" title="12.搜索引擎收录"></a>12.搜索引擎收录</h3><blockquote><p>使用的<a href="https://github.com/cjh0613/hexo-submit-urls-to-search-engine">插件</a>和具体<a href="https://cjh0613.com/20200603HexoSubmitUrlsToSearchEngine.html">步骤</a></p><p>目前我使用赛谷歌推送有问题.</p></blockquote><h2 id="9-静态页面托管-CodingPage"><a href="#9-静态页面托管-CodingPage" class="headerlink" title="9.静态页面托管_CodingPage"></a>9.静态页面托管_CodingPage</h2><blockquote><p>codingpage和githubpage一个道理都是静态代码的托管页面,区别是coding在国内访问会更好些,同时在阿里的域名解析中加入coding的地址这样让访问更稳定些.</p></blockquote><ol><li>注册并进入coding页面,然后创建新项目_代码托管项目,项目名称无所谓,自己方便记忆就好</li></ol><img src="https://i.loli.net/2020/11/23/o4x7SWcPTJHfL53.png" alt="image-20201123003130106" style="zoom: 67%;" /><ol start="2"><li><p>点击<code>代码仓库</code>然后<code>新建代码仓库</code>,自己取名字,然后<code>取消代码扫描</code>,然后<code>确定</code></p></li><li><p>复制ssh到博客配置文件,在<code>deploy</code>中进行如下配置</p><img src="https://i.loli.net/2020/11/23/dwSDH9GzepvMtZ3.png" alt="image-20201123004109744" style="zoom:67%;" /><img src="https://i.loli.net/2020/11/23/FHkQWZD6uvdglnw.png" alt="image-20201123004322925" style="zoom:67%;" /></li></ol><ol start="4"><li><p>原来的ssh公钥保存在id_rsa.pub中,复制出来,和github一样添加到ssh公钥中</p></li><li><p>保存并执行<code>hexo g -d</code>,推送成功后开始静态页面配置</p></li><li><p>返回刚才的代码仓库,点开左下角的<code>项目配置</code>,然后<code>功能开关</code>中点开<code>持续集成</code>,然后返回<code>代码仓库</code>,点击<code>持续部署</code>然后<code>静态网站</code>,等<code>权限配置</code>和<code>实名认证</code>完后<code>新建静态网站</code>,下面的网站类型可选项较多.</p><img src="https://i.loli.net/2020/11/23/LBKRnm2ZvDVgqlM.png" alt="image-20201123005143711" style="zoom: 50%;" /><img src="https://i.loli.net/2020/11/23/76OI2ahSTbYQ9KP.png" alt="image-20201123005212619" style="zoom: 77%;" /></li><li><p>由于我们在本地生成并上传的是静态页面,所以这里直接选择<code>静态页面</code>就可以了,当然了,如果希望直接托管所有项目代码,然后线上生成静态页面的话就可以选择<code>hexo</code>,这里看你怎么考虑,如果所有步骤和前面一致的话就选择<code>静态页面</code>,等它部署完会生成一个地址,然后再到阿里域名(我买的阿里域名)中心把地址和域名绑定就好了.</p></li><li><p>完结,睡觉</p></li></ol><h2 id="10-需要研究"><a href="#10-需要研究" class="headerlink" title="10.需要研究"></a>10.需要研究</h2><blockquote><p>网上找的一部分,还没细看</p></blockquote><p>常用文件和作用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base<span class="selector-class">.pug</span>        集成head部分模版+底部</span><br><span class="line">archive<span class="selector-class">.pug</span>        归档页的模版</span><br><span class="line">page<span class="selector-class">.pug</span>        自定义页面的模版</span><br><span class="line">post<span class="selector-class">.pug</span>        文章页模版</span><br><span class="line"><span class="selector-tag">footer</span><span class="selector-class">.pug</span>        尾部文件模版</span><br><span class="line">footer02<span class="selector-class">.pug</span>      底部菜单模版</span><br><span class="line">head<span class="selector-class">.pug</span>        首页的模版（主要是通用JS的引用，如评论，计数器）</span><br><span class="line">_footer文件夹      底部菜单各模版</span><br></pre></td></tr></table></figure><p>详细教程:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">底部菜单栏diy:</span><br><span class="line">    _footer文件夹</span><br><span class="line">    添加:</span><br><span class="line">         在_footer文件夹中新建xxx.pug,写上内容</span><br><span class="line">         在config文件中的footer下 添加进去 -xxx  即可显示</span><br><span class="line">    修改:</span><br><span class="line">        gywo.pug        <span class="comment">##关于我</span></span><br><span class="line">        gzhao.pug       <span class="comment">##公众号或微信二维码</span></span><br><span class="line">        xzhao.pug          <span class="comment">##百度熊掌号相关信息</span></span><br><span class="line">        links.pug          <span class="comment">##友情链接/关于本站/关于博主(简历)</span></span><br><span class="line">友情链接:</span><br><span class="line">    sources<span class="regexp">/href/i</span>ndex.md</span><br><span class="line">关于本站:</span><br><span class="line">    sources<span class="regexp">/site/i</span>ndex.md</span><br><span class="line">关于博主:</span><br><span class="line">    sources<span class="regexp">/about/i</span>ndex.md</span><br><span class="line">留言:</span><br><span class="line">    sources<span class="regexp">/comment/i</span>ndex.md</span><br><span class="line">工具:</span><br><span class="line">    sources<span class="regexp">/tool/i</span>ndex.md</span><br><span class="line">音乐:</span><br><span class="line">    sources<span class="regexp">/music/i</span>ndex.md</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/19/hello-world/"/>
      <url>2020/11/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
